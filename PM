-- Converted using Mokiros's Model to Script Version 3
-- Converted string size: 52140 characters

local ScriptFunctions = {
function(script,require)
script.Parent.Parent.Click.ClickDetector.MouseHoverEnter:Connect(function()
	if script.Parent.CanCollide == false then
		script.Parent.Transparency = 0.7
	end
end)

script.Parent.Parent.Click.ClickDetector.MouseHoverLeave:Connect(function()
	if script.Parent.CanCollide == false then
		script.Parent.Transparency = 1
	end
end)

script.Parent.Parent.Click.ClickDetector.MouseClick:Connect(function()
if script.Parent.Transparency == 0 then
	script.Parent.Transparency = 1
	script.Parent.CanCollide = false
else
	script.Parent.Transparency = 0
	script.Parent.CanCollide = true
end
end)

end,
function(script,require)
--Don't edit anything below unless you can script well!

repeat wait() until game.Players.LocalPlayer --This line makes the tool wait until it is in the Player's backpack
wait(0.1)
------------------------------------------------------------------
local Player = game.Players.LocalPlayer
local Character = Player.Character
local Plane = Character.Plane
local AutoCrash = Plane.AutoCrash
local Crashed = Plane.Crashed
local MainParts = Plane.MainParts
local Gear = MainParts.Gear
local Engine = MainParts.Engine
local Thrust = Engine.Thrust
local Direction = Engine.Direction
local Customize = Plane.Customize
local Events = Plane.Events
local Tool = script.Parent
local GUI = Tool.PlaneGui
local ToolSelect = Tool.ToolSelect
local Deselect0 = Tool.Deselect0
local Camera = game.Workspace.CurrentCamera
local RunService = game:GetService("RunService")
local uis = game:GetService("UserInputService")
------------------------------------------------------------------
local Acceleration = Customize.Acceleration
local MaxSpeed = Customize.MaxSpeed
local StallSpeed = Customize.StallSpeed
local TurnSpeed = Customize.TurnSpeed
local ThrottleInc = Customize.ThrottleInc
local MaxBank = Customize.MaxBank
local CameraType = Customize.CameraType
local CamLock = Customize.CamLock
local Ejectable = Customize.Ejectable
local PlaneName = Customize.PlaneName
local FlightControls = Customize.FlightControls
local SimulationMode = Customize.SimulationMode
local AltRestrict = Customize.AltitudeRestrict
local MaxAltitude = AltRestrict.MaxAltitude
local MinAltitude = AltRestrict.MinAltitude
local FlareSpeed = Customize.FlareSpeed
------------------------------------------------------------------
local GUIA1Visible = false
local GUIA2Visible = false
------------------------------------------------------------------
local SUAK = false
local SDAK = false
------------------------------------------------------------------
local EngineOn = false
local Selected = false
local LockedCam = false
local pan = Vector2.new()
local delta = Vector2.new()
local panLimit = 2
local targetfov = 70
local LowestPoint = 0
local DesiredSpeed = 0
local CurrentSpeed = 0
local TrueAirSpeed = 0
local Throttle = 0
local Pedal = 0
local Rudder = 0
local Brake = false
local accel = 0
local Flaps = 0
local Pitch = 0
local Roll = 0
local mass = 0
local inertia = 0
local HugeVector = Vector3.new(math.huge,math.huge,math.huge)
local lookVector = Vector3.new(0,0,0)
------------------------------------------------------------------
local FTab = {}
local IgnoreTable = {}
------------------------------------------------------------------
local LockGUI = nil
local Zoomed = false
local Locked = false
local Last = Vector3.new()--Character.Head:WaitForChild("Cframe").lookVector
local Current = Vector3.new()
local Gs = 0
------------------------------------------------------------------
local AimingIcon = "http://www.roblox.com/asset/?id=107455536"
local LockedIcon = "http://www.roblox.com/asset/?id=107455986"
local NormalIcon = "rbxassetid://4884403556"--"rbxasset://textures/MouseLockedCursor.png"
------------------------------------------------------------------
local LandingGear = {}
local planeParts = {}
local GearUp = false 

--End of the variables
------------------------------------------------------------------

function FixVars() --This function fixes any errors in the Customize folder
	Acceleration2 = (Acceleration.Value < 0 and 0 or Acceleration.Value > 1e3 and 1e3 or Acceleration.Value)
	MaxBank2 = (MaxBank.Value < -90 and -90 or MaxBank.Value > 90 and 90 or MaxBank.Value)
	MaxSpeed2 = (MaxSpeed.Value < 0 and 0 or MaxSpeed.Value < StallSpeed.Value and StallSpeed.Value or MaxSpeed.Value)
	StallSpeed2 = (StallSpeed.Value < 0 and 0 or StallSpeed.Value > MaxSpeed.Value and MaxSpeed.Value or StallSpeed.Value)
	TurnSpeed2 = (TurnSpeed.Value < 0 and 0 or TurnSpeed.Value)
	ThrottleInc2 = (ThrottleInc.Value < 0 and 0 or ThrottleInc.Value)
	MaxAltitude2 = (MaxAltitude.Value < MinAltitude.Value and MinAltitude.Value or MaxAltitude.Value)
	MinAltitude2 = (MinAltitude.Value > MaxAltitude.Value and MaxAltitude.Value or MinAltitude.Value)
	CameraType2 = (pcall(function() Camera.CameraType = CameraType.Value end) and CameraType.Value or "Custom")
	PlaneName2 = (PlaneName.Value == "" and "Plane" or PlaneName.Value)
	if FlightControls.SpeedUp.Value == "ArrowKeyUp" then
		SpeedUp2 = 17
		SUAK = true
	elseif FlightControls.SpeedUp.Value == "ArrowKeyDown" then
		SpeedUp2 = 18
		SUAK = true
	else
		SpeedUp2 = FlightControls.SpeedUp.Value
		SUAK = false
	end
	if FlightControls.SlowDown.Value == "ArrowKeyUp" then
		SlowDown2 = 17
		SDAK = true
	elseif FlightControls.SlowDown.Value == "ArrowKeyDown" then
		SlowDown2 = 18
		SDAK = true
	else
		SlowDown2 = FlightControls.SlowDown.Value
		SDAK = false
	end
	Engine.Direction.P = 1e4
end

function IsIgnored(Obj)
	for _,v in pairs(IgnoreTable) do
		if v == Obj then
			return true
		end
	end
	return false
end
function scan(p)
	for _,v in pairs(p:GetChildren()) do
		if v:IsA("BasePart") then
			table.insert(planeParts,v)
		end
		scan(v)
	end
end
scan(Plane)
for _,v in pairs(planeParts) do
	mass = mass+v:GetMass()
	print(mass)
end

function lastVector(old)
	wait(0.5+inertia/3)
	Last = old -- Update the previous camera rotation
end

function ScanPlayers(Pos,Radius) --This is a function that I created that efficiently puts a CreatorTag in the player
	coroutine.resume(coroutine.create(function()
		for _,v in pairs(game.Players:GetPlayers()) do --This gets all the players
			if v.Character and v.Character:findFirstChild("Torso") then
				local PTorso = v.Character.Torso
				if ((PTorso.Position - Pos).magnitude + 2) <= Radius then --If the distance between the explosion and the player is less than the radius...
					local HitHumanoid = v.Character:findFirstChild("Humanoid")
					if HitHumanoid then
						local CreatorTag = Instance.new("ObjectValue")
						CreatorTag.Name = "creator"
						CreatorTag.Value = Player
						CreatorTag.Parent = HitHumanoid
						delay(0.1,function() CreatorTag:Destroy() end)
					end
				end
			end
		end
	end))
end

function IncreaseSpd() --This function increases the speed
	if EngineOn then
		if Selected then
			while Accelerating do
				Events.Throttle:FireServer(Throttle)
				Throttle = (Throttle < 1 and Throttle + 0.003 or 1)
				if not Brake then
					DesiredSpeed = MaxSpeed2 * Throttle
				end
				
				Engine.Throttle.Value = Throttle
				wait(ThrottleInc2)
			end
		end
	end
end

function DecreaseSpd() --This function decreases the speed
	if EngineOn then
		if Selected then
			while Decelerating do
				Events.Throttle:FireServer(Throttle)
				Throttle = (Throttle > 0 and Throttle - 0.003 or 0)
				if not Brake then
					DesiredSpeed = MaxSpeed2 * Throttle
				end
				wait(ThrottleInc2)
				Engine.Throttle.Value = Throttle
			end
		end
	end
end

function RoundNumber(Num) --This function rounds a number to the nearest whole number
	return ((Num - math.floor(Num)) >= 0.5 and math.ceil(Num) or math.floor(Num))
end

function GetGear(Parent) --This function gets all the parts in the Gear folder
	for _,v in pairs(Parent:GetChildren()) do
		if (v:IsA("BasePart")) then
			if (not v:findFirstChild("GearProp")) then
				local GearProp = Instance.new("StringValue")
				GearProp.Name = "GearProp"
				GearProp.Value = v.Transparency..","..tostring(v.CanCollide)
				GearProp.Parent = v
			end
			table.insert(LandingGear,v) --This inserts a table with the gear's properties into the LandingGear table
		end
		GetGear(v)
	end
end

function ChangeGear() --This function extends or retracts the gear
	Events.Gear:FireServer()
end

uis.InputBegan:Connect(function(input)
if input.UserInputType == Enum.UserInputType.MouseButton2 and LockedCam then
	uis.MouseBehavior = Enum.MouseBehavior.LockCenter
	uis.MouseIconEnabled = false
else
	uis.MouseBehavior = Enum.MouseBehavior.Default
	uis.MouseIconEnabled = true
end
end)

uis.InputEnded:Connect(function(input)
if input.UserInputType == Enum.UserInputType.MouseButton2 then
	uis.MouseBehavior = Enum.MouseBehavior.Default
	uis.MouseIconEnabled = true
end
end)

Player:GetMouse().WheelBackward:Connect(function()
if LockedCam then
	targetfov += 5
end
end)

Player:GetMouse().WheelForward:Connect(function()
if LockedCam then
	targetfov -= 5
end
end)
--[[function SetUpGUI() --This function sets up the PlaneGUI
	local GUI = GUIClone.Main
	GUI.Title.Text = PlaneName2
	local HUD = GUI.Parent.HUD
	local ControlsA1 = GUI.Controls
	local FrameA1 = GUI.ControlsFrame
	local C1A1,C2A1,C3A1,C4A1,C5A1,C6A1 = FrameA1.C1.Key,FrameA1.C2.Key,FrameA1.C3.Key,FrameA1.C4.Key,FrameA1.C5.Key,FrameA1.C6.Key
	local ControlsA2 = HUD.Controls
	local FrameA2 = HUD.ControlsFrame
	local C1A2,C2A2,C3A2,C4A2,C5A2,C6A2 = FrameA2.C1.Key,FrameA2.C2.Key,FrameA2.C3.Key,FrameA2.C4.Key,FrameA2.C5.Key,FrameA2.C6.Key
	local GearText = GUI.Gear
	local MaxSpeedScaled = math.ceil(MaxSpeed2/50)
	for i = 1,(MaxSpeedScaled + 10) do --This creates a loop that clones the SpeedGUI and positions it accordingly
		local SpeedGUI = HUD.Speed.Main
		local Speed0 = SpeedGUI["Speed-0"]
		local SpeedClone = Speed0:clone()
		SpeedClone.Position = UDim2.new(0,0,1,-(80 + (75 * i)))
		SpeedClone.Name = ("Speed-%i"):format(50 * i)
		SpeedClone.Text.Text = tostring(50 * i)
		SpeedClone.Parent = SpeedGUI
	end
	local MaxAltScaled = math.ceil(MaxAltitude2/500)
	for i = 1,(MaxAltScaled + 10) do --This creates a loop that clones the AltitudeGUI and positions it accordingly
		local AltGUI = HUD.Altitude.Main
		local Altitude0 = AltGUI["Altitude-0"]
		local AltClone = Altitude0:clone()
		AltClone.Position = UDim2.new(0,0,1,-(80 + (75 * i)))
		AltClone.Name = ("Altitude-%s"):format(tostring(0.5 * i))
		AltClone.Text.Text = tostring(0.5 * i)
		AltClone.Parent = AltGUI
	end
	GearText.Text = (GearUp and "Gear Up" or "Gear Down")
	-------------------------------------------------------------------------------------
	C1A1.Text = "Key: "..FlightControls.Engine.Value:upper()
	C2A1.Text = "Key: "..FlightControls.SpeedUp.Value:upper()
	C3A1.Text = "Key: "..FlightControls.SlowDown.Value:upper()
	C4A1.Text = "Key: "..FlightControls.Gear.Value:upper()
	C5A1.Text = "Key: "..FlightControls.ToggleHUD.Value:upper()
	if not CamLock.Value then
		C5A1.Text = "Disabled"
	end
	C6A1.Text = "Key: "..FlightControls.Eject.Value:upper()
	if not Ejectable.Value then
		C6A1.Text = "Disabled"
	end
	ControlsA1.MouseButton1Click:connect(function() --This function allows the Flight Controls frame to be opened or closed without an external script
		if GUIA1Visible then
			GUIA1Visible = false
			FrameA1:TweenPosition(UDim2.new(0,0,0,-206),"In","Quad",1,true)
		elseif (not GUIA1Visible) then
			GUIA1Visible = true
			FrameA1:TweenPosition(UDim2.new(0,0,0,150),"Out","Quad",1,true)
		end
	end)
	-------------------------------------------------------------------------------------
	C1A2.Text = "Key: "..FlightControls.Engine.Value:upper()
	C2A2.Text = "Key: "..FlightControls.SpeedUp.Value:upper()
	C3A2.Text = "Key: "..FlightControls.SlowDown.Value:upper()
	C4A2.Text = "Key: "..FlightControls.Gear.Value:upper()
	C5A2.Text = "Key: "..FlightControls.ToggleHUD.Value:upper()
	if not CamLock.Value then
		C5A2.Text = "Disabled"
	end
	C6A2.Text = "Key: "..FlightControls.Eject.Value:upper()
	if not Ejectable.Value then
		C6A2.Text = "Disabled"
	end
	ControlsA2.MouseButton1Click:connect(function() --This function allows the Flight Controls frame to be opened or closed without an external script
		if GUIA2Visible then
			GUIA2Visible = false
			FrameA2:TweenPosition(UDim2.new(0.5,-150,0,-186),"In","Quad",1,true)
		elseif (not GUIA2Visible) then
			GUIA2Visible = true
			FrameA2:TweenPosition(UDim2.new(0.5,-150,0,30),"Out","Quad",1,true)
		end
	end)
end]]

function GetRoll(CF) --This function gets the rotation of the Engine. Credit to DevAdrian for this
	local CFRight = CF * CFrame.Angles(0,math.rad(90),0)
	local CFNoRollRight = CFrame.new(CF.p,CF.p + CF.lookVector) * CFrame.Angles(0,math.rad(90),0)
	local CFDiff = CFRight:toObjectSpace(CFNoRollRight)
	return (-math.atan2(CFDiff.lookVector.Y, CFDiff.lookVector.Z) % (math.pi * 2) + math.pi)
end

function GetPitch(CF) --This function gets the pitch of the Engine. Credit to DevAdrian for this
	local LV = CF.lookVector
	local XZDist = math.sqrt(LV.x ^ 2 + LV.z ^ 2)
	return math.atan(LV.y / XZDist)
end

function UpdateCamera() --This function uses the RunService to update the camera. It happens very fast so it is smooth
	Camera.FieldOfView = math.clamp(Camera.FieldOfView + (targetfov-Camera.FieldOfView)*0.05, 10, 100)
	if (not LockedCam) then
		Camera.CameraType = CameraType2
	elseif LockedCam then
		Camera.CameraType = Enum.CameraType.Scriptable
		delta = uis:GetMouseDelta()
		if uis.MouseBehavior ~= Enum.MouseBehavior.Default then
			pan = pan + Vector2.new(delta.X/1000,delta.Y/1000)
			pan = Vector2.new(math.clamp(pan.X, -panLimit, panLimit),math.clamp(pan.Y, -panLimit, panLimit))
		else
			pan -= pan*0.05
		end
			Camera.CoordinateFrame = Character.Head.CFrame:ToWorldSpace(CFrame.Angles(pan.Y - ((M2.Y/M2.ViewSizeY)-0.5)/2,pan.X - ((M2.X/M2.ViewSizeX)-0.5)/2,0)) + Character.Head.CFrame.LookVector * math.abs(pan.X) / 2
	end
end

function UpdateGUI(Taxiing,Stalling) --This function updates the GUI.
	local GUI = GUIClone:WaitForChild("Main")
	--local HUD = GUIClone:WaitForChild("HUD")
	GUI.Visible = (not LockedCam)
	--HUD.Visible = LockedCam
	--if LockedCam then UpdateHUD(HUD) end
	GUI.PullUp.Visible = (EngineOn and (not Taxiing) and (AltRestrict.Value) and (Engine.Position.Y < (MinAltitude2 + 20)))
	GUI.Taxi.Visible = (EngineOn and Taxiing)
	GUI.Stall.Visible = ((not Taxiing) and Stalling)
	GUI.Altitude.Text = "Altitude: "..RoundNumber(Engine.Position.Y)
	GUI.Speed.Text = "Speed: "..RoundNumber(TrueAirSpeed)
	GUI.Throttle.Bar.Tray.Size = UDim2.new(Throttle,0,1,0)
	GUI.Throttle.Percent.Text = math.abs(math.floor(Throttle * 100)).."%"
end

function CalculateSpeed() --This function calculates the current speed
	while Selected do
		if EngineOn then
			accel = (TrueAirSpeed/MaxSpeed2)+(Throttle/2)+0.025
			CurrentSpeed = (CurrentSpeed < DesiredSpeed and CurrentSpeed + accel or CurrentSpeed - 1) --A simple ternary operation that calculates the currentspeed
			CurrentSpeed = (CurrentSpeed < 0 and 0 or CurrentSpeed > MaxSpeed2 and MaxSpeed2 or CurrentSpeed) --This fixes the currentspeed
		end
		Engine.Throttle.Value = Throttle
		wait(0.2 - (Acceleration2/5e3))
	end
end

function GetLowestPoint() --This function gets the lowest point of the plane (Credit to Crazyman32 for this)
	if (#LandingGear == 0) then
		LowestPoint = (Engine.Position.Y + 5 + (Engine.Size.Y/2))
		return
	end
	for _,v in pairs(LandingGear) do
		local Set0 = (Engine.Position.Y - (v.CFrame * CFrame.new((v.Size.X/2),0,0)).Y)
		local Set1 = (Engine.Position.Y - (v.CFrame * CFrame.new(-(v.Size.X/2),0,0)).Y)
		local Set2 = (Engine.Position.Y - (v.CFrame * CFrame.new(0,(v.Size.Y/2),0)).Y)
		local Set3 = (Engine.Position.Y - (v.CFrame * CFrame.new(0,-(v.Size.Y/2),0)).Y)
		local Set4 = (Engine.Position.Y - (v.CFrame * CFrame.new(0,0,(v.Size.Z/2))).Y)
		local Set5 = (Engine.Position.Y - (v.CFrame * CFrame.new(0,0,-(v.Size.Z/2))).Y)
		local Max = (math.max(Set0,Set1,Set2,Set3,Set4,Set5) + 5)
		LowestPoint = (Max > LowestPoint and Max or LowestPoint)
	end
end

function GetBankAngle(M) --This function calculates the Bank Angle (Credit to Crazyman32 for this)
	local VSX,X = M.ViewSizeX,M.X
	local Ratio = (((VSX / 2) - X)/(VSX / 2))
	Ratio = (Ratio < -1 and -1 or Ratio > 1 and 1 or Ratio)
	return math.rad(Ratio * MaxBank2)
end

function Taxi() --This function determines whether the plane is taxiing or not
	return TrueAirSpeed <= StallSpeed2
end
function onGround()
	local Ray = Ray.new(Engine.Position,Vector3.new(0,-LowestPoint,0))
	return game.Workspace:FindPartOnRay(Ray,Plane) == true
end

function Stall() --This function determines whether the plane is stalling or not
	return ((AltRestrict.Value and Engine.Position.Y > MaxAltitude2) or TrueAirSpeed < StallSpeed2)
end

function FlyMain(M) --This is the main flying function
	if Selected then
		Rudder = math.clamp(Rudder + Pedal*0.1,-2,2) - math.sign(Rudder)/30
		local BankAngle = GetBankAngle(M) --This uses the "GetBankAngle" function to calculate the Bank Angle
		local Taxi,Stall = Taxi(),Stall()
		if EngineOn then
			Engine.Pitch.Value = ((M.ViewSizeY / 2) - M.Y) / (M.ViewSizeY / 2) 
			Engine.Roll.Value = ((M.ViewSizeX / 2) - M.X) / (M.ViewSizeX / 2)
			Pitch = ((M.ViewSizeY / 2) - M.Y) / (M.ViewSizeY / 2) 
			Roll = ((M.ViewSizeX / 2) - M.X) / (M.ViewSizeX / 2)
			inertia = Pitch*math.sign(Pitch)
			lastVector(Engine.CFrame.lookVector)
			Engine.Thrust.velocity = ((Engine.CFrame.lookVector/2) + (Last/2)) * Vector3.new(CurrentSpeed,  CurrentSpeed, CurrentSpeed) + Vector3.new(0, (CurrentSpeed < 220 and ((CurrentSpeed < 200 and -25) or -15) or -5),0)
			if Taxi then
				local VSX,X = M.ViewSizeX,M.X
				local YawSpeed = Rudder / 50
				Thrust.maxForce = Vector3.new(math.huge,100000,math.huge)
				Direction.maxTorque = Vector3.new(0,math.huge,0)
				Direction.cframe = Engine.CFrame * CFrame.Angles(0,-YawSpeed,0)
			else
				Thrust.maxForce = Vector3.new(math.huge, math.huge, math.huge)
				Direction.maxTorque = HugeVector
				local Rotation = 2 * math.pi - GetRoll(Engine.CFrame)
				local YawRotation = math.rad(math.sin(Rotation/(8*TrueAirSpeed / MaxSpeed2)))
				local YawSpeed =  Rudder / 100 + (math.abs(Rotation) > math.pi / 2 and YawRotation/2 or YawRotation) 
				local SpeedScale = TrueAirSpeed / MaxSpeed2
				local PitchSpeed = SimulationMode.PitchSpeed.Value * SpeedScale + 0.5
				local RollSpeed = SimulationMode.RollSpeed.Value * SpeedScale + 1
				local VSX,X = M.ViewSizeX,M.X
				local VSY,Y = M.ViewSizeY,M.Y
				local RatioX = math.rad(((VSX / 2) - X) / (VSX / 2))
				local RatioY = math.rad(((VSY / 2) - Y) / (VSY / 2))
				Direction.cframe = Engine.CFrame * CFrame.Angles(RatioY * PitchSpeed,-YawSpeed,RatioX * RollSpeed)
			end
			if ((AltRestrict.Value) and (Engine.Position.Y < MinAltitude2)) then --If there are altitude restrictions and you are below it...
				AutoCrash.Value = true
			end
		elseif (not EngineOn) then
			Thrust.maxForce = Vector3.new(0,0,0)
			Thrust.velocity = Vector3.new(0,0,0)
			Direction.maxTorque = Vector3.new(0,0,0)
		end
		TrueAirSpeed = Engine.Velocity.magnitude
		UpdateGUI(Taxi,Stall) --This activates the "UpdateGUI" function
	end
end

--Control Surfaces
Engine.Pitch.Changed:Connect(function()
	Events.Elevators:FireServer(Pitch)
end)
Engine.Roll.Changed:Connect(function()
	Events.Ailerons:FireServer(Roll)
end)

function onKeyDown(Key) --This function is activated whenever a key is pressed
	local Key = Key:lower()
	if (Key == FlightControls.Engine.Value:lower()) then --If you press the engine key...
		local GUI = GUIClone.Main
		Events.Engine:FireServer(not EngineOn)
		print("enginestart")
		if (not EngineOn) then	
			EngineOn = true
			DesiredSpeed = 0
			CurrentSpeed = 0
			Throttle = 0
			GUI.Engine.Visible = false
			CalculateSpeed()
		elseif EngineOn then
			EngineOn = false
			DesiredSpeed = 0
			CurrentSpeed = 0
			Throttle = 0
			GUI.Engine.Visible = true
		end
	end
	if (Key == FlightControls.Gear.Value:lower()) then --If you press the change gear key...
		local GUI = GUIClone.Main
		local Taxiing = Taxi()
		if (#LandingGear ~= 0) then
			--if (not Taxiing) then
				ChangeGear()
				if (not GearUp) then
					GearUp = true
					GUI.Gear.Text = "Gear Up"
				elseif GearUp then
					GearUp = false
					GUI.Gear.Text = "Gear Down"
				end
			--end
		end
	end




---- Custom functions
	if (Key == FlightControls.Gun.Value:lower()) then
		Events.Gun:FireServer(true)
	end
	if (Key == FlightControls.Right.Value:lower()) then--Rudder Right
		Pedal = 1
	end
	if (Key == FlightControls.Left.Value:lower()) then--Rudder Left
		Pedal = -1
	end
	if (Key == FlightControls.Smoke.Value:lower()) then--Smoke toggle
		Events.Smoke:FireServer()
	end
	if (Key == FlightControls.Brake.Value:lower()) then
		Brake = true
		DesiredSpeed = 0
		Events.Brake:FireServer(Brake)
	end
	if (Key == FlightControls.Canopy.Value:lower()) then
		Events.Canopy:FireServer()
	end
	if (Key == FlightControls.Flaps.Value:lower()) then
		if Flaps == 0 then
		Flaps = 1
		else
		Flaps = 0
		end
		Events.Flaps:FireServer(Flaps)
	end
	if (Key == FlightControls.CamToggle.Value:lower()) then --Its to throttle up XD
		for i = Throttle, 1, 0.02 do
		Throttle = i
		Events.Throttle:FireServer(Throttle)
		wait()
		end
		Throttle = 1
		if not Brake then
			DesiredSpeed = MaxSpeed2 * Throttle
		end
	
	end
----



	if SUAK and Key:byte() == SpeedUp2 or (not SUAK) and (Key == SpeedUp2) then --If you press the speed up key...
		Accelerating = true
		IncreaseSpd()
	end
	if SDAK and Key:byte() == SlowDown2 or (not SDAK) and (Key == SlowDown2) then --If you press the slow down key...
		Decelerating = true
		DecreaseSpd()
	end
	if (Key == FlightControls.Eject.Value:lower()) then
		if EngineOn then
			local Taxiing = Taxi()
			if (not Taxiing) then
				if Ejectable.Value then
					if (not Plane.Ejected.Value) then
						Plane.Ejected.Value = true
						local Seat = MainParts.Seat
						local EjectClone = Tool.Ejector:clone()
						EjectClone.Parent = Player.PlayerGui
						EjectClone.Disabled = false
						local Fire = Instance.new("Fire")
						Fire.Parent = Engine
						Fire.Heat = 25
						Fire.Size = 30
						local Smoke = Instance.new("Smoke")
						Smoke.Parent = Engine
						Smoke.Color = Color3.new(1/3,1/3,1/3)
						Smoke.Opacity = 0.7
						Smoke.RiseVelocity = 10
						Smoke.Size = 10
						onDeselectForced()
						Seat.SeatWeld:Destroy()
					end
				end
			end
		end
	end
	if (Key == FlightControls.ToggleHUD.Value:lower()) then
		LockedCam = (not LockedCam)
			if LockedCam then
			targetfov = 90
				for i,v in pairs(Character:GetDescendants()) do
					if not v:IsDescendantOf(Plane) then
						if v:IsA("BasePart") and v.Name ~= "HumanoidRootPart" then
							
							v.Transparency = 1
						end
					end
				end
			else
				targetfov = 70
				for i,v in pairs(Character:GetDescendants()) do
					if not v:IsDescendantOf(Plane) then
						if v:IsA("BasePart") and v.Name ~= "HumanoidRootPart" then
							v.Transparency = 0
						end
					end
				end
			end
		end
	end

function onKeyUp(Key) --This function is activated when you let go of a key
	local Key = Key:lower()
	if Key == FlightControls.Gun.Value then
		Events.Gun:FireServer(false)
		print("hi")
	end
	if SUAK and Key:byte() == SpeedUp2 or (not SUAK) and (Key == SpeedUp2) then --If you let go of the speed up key...
		Accelerating = false
	end
	if SDAK and Key:byte() == SlowDown2 or (not SDAK) and (Key == SlowDown2) then --If you let go of the slow down key...
		Decelerating = false
	end
	if Key == FlightControls.Right.Value or Key == FlightControls.Left.Value then
		Pedal = 0
	end   
	if Key == FlightControls.Brake.Value then
		Brake = false
		DesiredSpeed = MaxSpeed2 * Throttle
		Events.Brake:FireServer(Brake)
	end
	
end

function onSelected(M) --This function is activated when you select the Plane tool
	Selected = true
	M2 = M
	Character.Humanoid.JumpPower = 0 
	FixVars() --This activates the "FixVars" function
	GetGear(Gear) --This activates the "GetGear" function
	GetLowestPoint() --This activates the "GetLowestPoint" function
	ToolSelect.Value = true
	GUIClone = GUI:clone() --This line and the next one clones the plane GUI and puts it into the player
	GUIClone.Parent = Player.PlayerGui
	--SetUpGUI() --This activates the "SetUpGui" function
	Camera.CameraType = CameraType2 --This makes your cameratype the customize cameratype
	M.Icon = NormalIcon
	FTab[1] = M.KeyDown:connect(onKeyDown)
	FTab[2] = M.KeyUp:connect(onKeyUp)
	FTab[3] = RunService.RenderStepped:connect(function() FlyMain(M) end)
	FTab[4] = RunService.RenderStepped:connect(UpdateCamera)
end

function onDeselected(M) --This function is activated when you deselect the Plane tool
	if Selected then
		Selected = false
		LockedCam = false
		for _,v in pairs(FTab) do --This disconnects all the connections. It prevents bugs
			if v then
				v:disconnect()
				v = nil
			end
		end
		Camera.CameraType = Enum.CameraType.Custom --This makes the CameraType "Custom"
		Camera.CameraSubject = Character.Humanoid
		Character.Humanoid.JumpPower = 50
		if (not Taxi()) and EngineOn then --If you're not Taxiing and your engine is on...
			if (not Deselect0.Value) and (not Plane.Ejected.Value) then --If you deselected the tool and didn't eject...
				onDeselectForced()
			end
		end
		CurrentSpeed = 0 --These couple of lines reset the plane
		DesiredSpeed = 0
		TrueAirSpeed = 0
		EngineOn = false
		Updating = false
		Locked = false
		ToolSelect.Value = false
		GUIAVisible = true
		GUIBVisible = true
		GUIClone:remove()
		if Engine:FindFirstChild("Thrust") then
			Engine.Thrust.velocity = Vector3.new(0,0,0)
			Engine.Thrust.maxForce = Vector3.new(0,0,0)
		end
		if Engine:FindFirstChild("Direction") then
			Engine.Direction.maxTorque = Vector3.new(0,0,0)
		end
	end
end

function onDeselectFlying() --This function blows up the plane
	if (not Deselect0.Value) then
		onDeselected()
		Plane:BreakJoints()
		local Explosion = Instance.new("Explosion")
		Explosion.Parent = game.Workspace
		Explosion.Position = Engine.Position
		Explosion.BlastRadius = Plane:GetModelSize().magnitude
		Explosion.BlastPressure = 2e4
		Character.Humanoid.Health = 0
		Engine.Thrust:remove()
		Engine.Direction:remove()
		delay(5,function()
			Plane:Destroy()
		end)
	end
end
local seat = MainParts.Seat
seat.Occupant.Changed:Connect(function()
if not seat.Occupant then
		onDeselected(true)
	end
end)

function onDeselectForced() --This function is activated when you get out of the plane without deselecting the tool first
	if Selected then
		for _,v in pairs(IgnoreTable) do
			if v then
				v:Destroy()
			end
		end
		onDeselected()
		M2.Icon = "rbxasset://textures\\ArrowCursor.png" --This makes the mouse icon the normal icon
	end
end

script.Parent.Selected:connect(onSelected) --The next 3 lines activate the given functions
script.Parent.Deselected:connect(onDeselected)
Deselect0.Changed:connect(onDeselectForced)
Crashed.Changed:connect(onDeselectForced)
end,
function(script,require)
repeat wait() until game.Players.LocalPlayer
local Player = game.Players.LocalPlayer
local Character = Player.Character
local Torso = Character:findFirstChild("Torso")
local Humanoid = Character:findFirstChild("Humanoid")
local Camera = game.Workspace.CurrentCamera
local Connection = nil
-------------------------------------------------
if Torso and Humanoid then
	Humanoid.Sit,Humanoid.Jump = true,false
	Connection = Humanoid.Changed:connect(function()
		Humanoid.Sit,Humanoid.Jump = true,false
	end)
	local Model = Instance.new("Model")
	Model.Parent = Character
	Model.Name = "EjectorSeat"
	-------------------------------------------------------------------------------------------
	local Seat = Instance.new("Part")
	Seat.Parent = Model
	Seat.Name = "Seat"
	Seat.CanCollide = false
	Seat.FormFactor = "Custom"
	Seat.Size = Vector3.new(2.5,1,2)
	Seat.BottomSurface = "Smooth"
	Seat.TopSurface = "Smooth"
	local Weld1 = Instance.new("Weld")
	Weld1.Parent = Seat
	Weld1.Part0 = Seat
	Weld1.Part1 = Torso
	Weld1.C0 = CFrame.new(0,2,0)
	-------------------------------------------------------------------------------------------
	local Part1 = Instance.new("Part")
	Part1.Parent = Model
	Part1.CanCollide = false
	Part1.FormFactor = "Symmetric"
	Part1.Size = Vector3.new(3,1,1)
	Part1.BottomSurface = "Smooth"
	Part1.TopSurface = "Smooth"
	local Weld2 = Instance.new("Weld")
	Weld2.Parent = Part1
	Weld2.Part0 = Part1
	Weld2.Part1 = Seat
	Weld2.C0 = CFrame.new(0,0,-1.5)
	-------------------------------------------------------------------------------------------
	local Part2 = Instance.new("Part")
	Part2.Parent = Model
	Part2.CanCollide = false
	Part2.FormFactor = "Symmetric"
	Part2.Size = Vector3.new(2,3,1)
	Part2.BottomSurface = "Smooth"
	Part2.TopSurface = "Smooth"
	local Weld3 = Instance.new("Weld")
	Weld3.Parent = Part2
	Weld3.Part0 = Part2
	Weld3.Part1 = Part1
	Weld3.C0 = CFrame.new(0,-2,0)
	-------------------------------------------------------------------------------------------
	local Wedge1 = Instance.new("WedgePart")
	Wedge1.Parent = Model
	Wedge1.CanCollide = false
	Wedge1.FormFactor = "Custom"
	Wedge1.Size = Vector3.new(1,3,0.5)
	Wedge1.BottomSurface = "Smooth"
	Wedge1.TopSurface = "Smooth"
	local Weld4 = Instance.new("Weld")
	Weld4.Parent = Wedge1
	Weld4.Part0 = Wedge1
	Weld4.Part1 = Part2
	Weld4.C0 = CFrame.new(0,0,1.25) * CFrame.Angles(0,math.rad(90),0)
	-------------------------------------------------------------------------------------------
	local Wedge2 = Instance.new("WedgePart")
	Wedge2.Parent = Model
	Wedge2.CanCollide = false
	Wedge2.FormFactor = "Custom"
	Wedge2.Size = Vector3.new(1,3,0.5)
	Wedge2.BottomSurface = "Smooth"
	Wedge2.TopSurface = "Smooth"
	local Weld5 = Instance.new("Weld")
	Weld5.Parent = Wedge2
	Weld5.Part0 = Wedge2
	Weld5.Part1 = Part2
	Weld5.C0 = CFrame.new(0,0,1.25) * CFrame.Angles(0,math.rad(-90),0)
	-------------------------------------------------------------------------------------------
	local Wedge3 = Instance.new("WedgePart")
	Wedge3.Parent = Model
	Wedge3.CanCollide = false
	Wedge3.FormFactor = "Custom"
	Wedge3.Size = Vector3.new(1,2,0.25)
	Wedge3.BottomSurface = "Smooth"
	Wedge3.TopSurface = "Smooth"
	local Weld6 = Instance.new("Weld")
	Weld6.Parent = Wedge3
	Weld6.Part0 = Wedge3
	Weld6.Part1 = Seat
	Weld6.C0 = CFrame.new(0,0,1.375) * CFrame.Angles(math.rad(90),0,math.rad(90))
	-------------------------------------------------------------------------------------------
	local Wedge4 = Instance.new("WedgePart")
	Wedge4.Parent = Model
	Wedge4.CanCollide = false
	Wedge4.FormFactor = "Custom"
	Wedge4.Size = Vector3.new(1,2,0.25)
	Wedge4.BottomSurface = "Smooth"
	Wedge4.TopSurface = "Smooth"
	local Weld7 = Instance.new("Weld")
	Weld7.Parent = Wedge4
	Weld7.Part0 = Wedge4
	Weld7.Part1 = Seat
	Weld7.C0 = CFrame.new(0,0,1.375) * CFrame.Angles(math.rad(90),0,math.rad(-90))
	-------------------------------------------------------------------------------------------
	local Part3 = Instance.new("Part")
	Part3.Parent = Model
	Part3.Name = "Main"
	Part3.CanCollide = false
	Part3.FormFactor = "Symmetric"
	Part3.Size = Vector3.new(1,4,1)
	Part3.BottomSurface = "Smooth"
	Part3.TopSurface = "Smooth"
	local Mesh1 = Instance.new("CylinderMesh")
	Mesh1.Parent = Part3
	local BV = Instance.new("BodyVelocity")
	BV.Parent = Part3
	BV.maxForce = Vector3.new(17e3,math.huge,17e3)
	BV.velocity = Vector3.new(0,700.15,0)
	local BG = Instance.new("BodyGyro")
	BG.Parent = Part3
	BG.maxTorque = Vector3.new(math.huge,0,math.huge)
	BG.cframe = CFrame.Angles(0,0,0)
	local Weld8 = Instance.new("Weld")
	Weld8.Parent = Part3
	Weld8.Part0 = Part3
	Weld8.Part1 = Part2
	Weld8.C0 = CFrame.new(0,0.5,-0.5)
	-------------------------------------------------------------------------------------------
	local Visual = Instance.new("Part")
	Visual.Parent = Model
	Visual.Transparency = 1
	Visual.Name = "Visual"
	Visual.CanCollide = false
	Visual.FormFactor = "Symmetric"
	Visual.Size = Vector3.new(1,1,1)
	Visual.BottomSurface = "Smooth"
	Visual.TopSurface = "Smooth"
	local Weld9 = Instance.new("Weld")
	Weld9.Parent = Visual
	Weld9.Part0 = Visual
	Weld9.Part1 = Part3
	Weld9.C0 = CFrame.new(0,-2.5,0) * CFrame.Angles(0,0,math.rad(180))
	local Fire = Instance.new("Fire")
	Fire.Parent = Visual
	Fire.Heat = 25
	Fire.Size = 10
	-------------------------------------------------------------------------------------------
	local Wire1 = Instance.new("Part")
	Wire1.Parent = Model
	Wire1.BrickColor = BrickColor.new("White")
	Wire1.Transparency = 1
	Wire1.Name = "Wire"
	Wire1.CanCollide = false
	Wire1.FormFactor = "Symmetric"
	Wire1.Size = Vector3.new(1,13,1)
	Wire1.BottomSurface = "Smooth"
	Wire1.TopSurface = "Smooth"
	local Mesh2 = Instance.new("CylinderMesh")
	Mesh2.Parent = Wire1
	Mesh2.Scale = Vector3.new(0.2,1,0.2)
	local Weld10 = Instance.new("Weld")
	Weld10.Parent = Wire1
	Weld10.Part0 = Wire1
	Weld10.Part1 = Part3
	Weld10.C0 = CFrame.new(-0.5,-8.3,0.5)
	Weld10.C1 = CFrame.Angles(math.rad(20),0,math.rad(20))
	-------------------------------------------------------------------------------------------
	local Wire2 = Instance.new("Part")
	Wire2.Parent = Model
	Wire2.BrickColor = BrickColor.new("White")
	Wire2.Transparency = 1
	Wire2.Name = "Wire"
	Wire2.CanCollide = false
	Wire2.FormFactor = "Symmetric"
	Wire2.Size = Vector3.new(1,13,1)
	Wire2.BottomSurface = "Smooth"
	Wire2.TopSurface = "Smooth"
	local Mesh3 = Instance.new("CylinderMesh")
	Mesh3.Parent = Wire2
	Mesh3.Scale = Vector3.new(0.2,1,0.2)
	local Weld11 = Instance.new("Weld")
	Weld11.Parent = Wire2
	Weld11.Part0 = Wire2
	Weld11.Part1 = Part3
	Weld11.C0 = CFrame.new(0.5,-8.3,0.5)
	Weld11.C1 = CFrame.Angles(math.rad(20),0,math.rad(-20))
	-------------------------------------------------------------------------------------------
	local Wire3 = Instance.new("Part")
	Wire3.Parent = Model
	Wire3.BrickColor = BrickColor.new("White")
	Wire3.Transparency = 1
	Wire3.Name = "Wire"
	Wire3.CanCollide = false
	Wire3.FormFactor = "Symmetric"
	Wire3.Size = Vector3.new(1,13,1)
	Wire3.BottomSurface = "Smooth"
	Wire3.TopSurface = "Smooth"
	local Mesh4 = Instance.new("CylinderMesh")
	Mesh4.Parent = Wire3
	Mesh4.Scale = Vector3.new(0.2,1,0.2)
	local Weld12 = Instance.new("Weld")
	Weld12.Parent = Wire3
	Weld12.Part0 = Wire3
	Weld12.Part1 = Part3
	Weld12.C0 = CFrame.new(-0.5,-8.3,-0.5)
	Weld12.C1 = CFrame.Angles(math.rad(-20),0,math.rad(20))
	-------------------------------------------------------------------------------------------
	local Wire4 = Instance.new("Part")
	Wire4.Parent = Model
	Wire4.BrickColor = BrickColor.new("White")
	Wire4.Transparency = 1
	Wire4.Name = "Wire"
	Wire4.CanCollide = false
	Wire4.FormFactor = "Symmetric"
	Wire4.Size = Vector3.new(1,13,1)
	Wire4.BottomSurface = "Smooth"
	Wire4.TopSurface = "Smooth"
	local Mesh5 = Instance.new("CylinderMesh")
	Mesh5.Parent = Wire4
	Mesh5.Scale = Vector3.new(0.2,1,0.2)
	local Weld13 = Instance.new("Weld")
	Weld13.Parent = Wire4
	Weld13.Part0 = Wire4
	Weld13.Part1 = Part3
	Weld13.C0 = CFrame.new(0.5,-8.3,-0.5)
	Weld13.C1 = CFrame.Angles(math.rad(-20),0,math.rad(-20))
	-------------------------------------------------------------------------------------------
	local Parachute = Instance.new("Part")
	Parachute.Parent = Model
	Parachute.BrickColor = BrickColor.new("Bright orange")
	Parachute.Transparency = 1
	Parachute.Name = "Parachute"
	Parachute.CanCollide = false
	Parachute.FormFactor = "Symmetric"
	Parachute.Size = Vector3.new(1,1,1)
	Parachute.BottomSurface = "Smooth"
	Parachute.TopSurface = "Smooth"
	local Mesh6 = Instance.new("SpecialMesh")
	Mesh6.Parent = Parachute
	Mesh6.MeshId = "http://www.roblox.com/asset/?id=1038653"
	Mesh6.MeshType = "FileMesh"
	Mesh6.Scale = Vector3.new(11,9,11)
	local Weld14 = Instance.new("Weld")
	Weld14.Parent = Parachute
	Weld14.Part0 = Parachute
	Weld14.Part1 = Part3
	Weld14.C0 = CFrame.new(0,-15,0)
	-------------------------------------------------------------------------------------------
	wait(2.5)
	BV.maxForce = Vector3.new(17e3,15e3,17e3)
	BV.velocity = Vector3.new(0,0.15,0)
	Fire.Enabled = false
	function RayCast()
		local SeatPos = Torso.CFrame.p
		local SeatDir = (Torso.CFrame.p - Vector3.new(0,1,0)).unit
		local Ray1 = Ray.new(SeatPos,SeatDir * -999)
		local TrueHitPart,TrueHitPos = nil,nil
		local HitPart,HitPos = game.Workspace:FindPartOnRayWithIgnoreList(Ray1,{Character,Camera})
		for i = 1,10 do
			if (not HitPart) then
				local Ray2 = Ray.new(HitPos,SeatDir * -999)
				local HitPart2,HitPos2 = game.Workspace:FindPartOnRayWithIgnoreList(Ray2,{Character,Camera})
				if i ~= 10 then
					if HitPart2 then
						TrueHitPart,TrueHitPos = HitPart2,HitPos2
						break
					elseif (not HitPart2) then
						HitPart,HitPos = HitPart2,HitPos2
					end
				elseif i == 10 then
					TrueHitPart,TrueHitPos = HitPart2,HitPos2
				end
			elseif HitPart then
				TrueHitPart,TrueHitPos = HitPart,HitPos
				break
			end
		end
		return TrueHitPart,TrueHitPos
	end
	local _,HitPos = RayCast()
	Spawn(function()
		while true do
			_,HitPos = RayCast()
			wait(0.05)
		end
	end)
	Spawn(function()
		while true do
			if (Seat.Position.y - HitPos.y) <= 1000 then
				break
			end
			wait()
		end
		BV.maxForce = Vector3.new(17e3,35e3,17e3)
		BV.velocity = Vector3.new(0,-100.15,0)
		Wire1.Transparency,Wire2.Transparency,Wire3.Transparency,Wire4.Transparency = 0,0,0,0
		Parachute.Transparency = 0
		while true do
			if (Seat.Position.y - HitPos.y) <= 20 then
				break
			end
			wait()
		end
		Connection:disconnect()
		Humanoid.Jump = true
		Humanoid.Sit = false
		Model:Destroy()
		game:GetService("Debris"):AddItem(script,0.1)
	end)
end
end,
function(script,require)
-- Variables for services
local canFire = true
local player = game.Players.LocalPlayer
local mouse = player:GetMouse()
local Tool = script.Parent
local cs = game:GetService("CollectionService")
local target = nil
local scanning = false
local targetpos = Vector2.new(1,1)
print(script.Parent.Name.." is working")

local function OnActivated()
	print("1")
	if canFire then
	print("2")
	script.Parent.FireEvent:FireServer(target)
	canFire = false
	wait(2)
	canFire = true
	end
end
local function Selected()
	scanning = true
	FindNearestTarget()
end

local function Deselected()
	for _,v in pairs(cs:GetTagged("target")) do
		if v:FindFirstChild("Targeting") then
			v:FindFirstChild("Targeting"):Destroy()
		end
	end
	scanning = false
end

function FindNearestTarget()
	if targetpos.X > 0.15 and targetpos.Y > 0.15 then
		target = nil
		targetpos = Vector2.new(math.huge,math.huge)
	end

	for _,v in pairs(cs:GetTagged("target")) do
		if v ~= script.Seat.Value then
			if v:FindFirstChild("Targeting") then
				v:FindFirstChild("Targeting"):Destroy()
			end
			local clone = script.Targeting:Clone()
			clone.Parent = v
			clone.Enabled = true
			local pos, onscreen = workspace.CurrentCamera:WorldToViewportPoint(v.Position)
			if onscreen then
				if Check(math.abs(pos.X/mouse.ViewSizeX-0.5), math.abs(pos.Y/mouse.ViewSizeY-0.5)) then
					target = v
				end
			end
			if v == target then
				v.Targeting.GreenCircle.ImageColor3 = Color3.new(1,0,0)
				targetpos = Vector2.new(math.abs(pos.X/mouse.ViewSizeX-0.5), math.abs(pos.Y/mouse.ViewSizeY-0.5))
			else
				v.Targeting.GreenCircle.ImageColor3 = Color3.new(0,1,0)
			end
		end
	end
	wait()
	if scanning then
	FindNearestTarget()
	end
end

function Check (posX, posY)
	if posX < 0.5 and posY < 0.15 then
		if posX < targetpos.X or posY < targetpos.Y then
			return true
		else
			return false
		end
	else
		return false
	end
end

-- Bind tool events
mouse.Button1Down:connect(OnActivated)
Tool.Selected:Connect(Selected)
Tool.Deselected:Connect(Deselected)
end,
function(script,require)
local tool = script.Parent
local canFire = true

-----------------
--| Constants |--
-----------------

local GRAVITY_ACCELERATION = 170

local MISSILE_MESH_ID = 'http://www.roblox.com/asset/?id=2251534'
local MISSILE_MESH_SCALE = Vector3.new(0.5, 1, 0.5)
local ROCKET_PART_SIZE = Vector3.new(1, 1, 3.27)

local fireEvent = script.Parent.FireEvent
--NOTE: We create the rocket once and then clone it when the player fires
local Rocket = game.ServerStorage.Missile:Clone() --Instance.new('Part') do
	--[[ Set up the rocket part
	Rocket.Name = 'Rocket'
	Rocket.FormFactor = Enum.FormFactor.Custom --NOTE: This must be done before changing Size
	Rocket.Size = ROCKET_PART_SIZE
	Rocket.CanCollide = true-- Add the mesh
	local mesh = Instance.new('SpecialMesh', Rocket)
	mesh.MeshId = MISSILE_MESH_ID
	mesh.Scale = MISSILE_MESH_SCALE]]

	-- Add a force to counteract gravity
	local thrust = Instance.new('RocketPropulsion', Rocket)
	thrust.Name = 'Thrust'
	thrust.MaxSpeed = 600
	thrust.CartoonFactor = 1
	thrust.TurnD = 500
	thrust.TargetRadius = 10
	thrust.MaxThrust = 4000
	
	--local attachment1,attachment2 = Instance.new("Attachment", Rocket), Instance.new("Attachment", Rocket) attachment1.Position, attachment1.Position  = Vector3.new(0,-30,0), Vector3.new(0,10,0)
	--Extra bits taco added in
	
	--[[for _,v in pairs(game.ServerStorage.Missile:GetChildren()) do
		v:Clone().Parent = Rocket
	end]]

	-- Finally, clone the rocket script and enable it
--	local rocketScriptClone = RocketScript:Clone()
--	rocketScriptClone.Parent = Rocket
--	rocketScriptClone.Disabled = false


fireEvent.OnServerEvent:connect(function(player, target)
	print("3")
	if player == script.Parent.Parent.Parent and target ~= nil then
	print("4")
		local Tracker = Instance.new("ObjectValue",target)
		Tracker.Name = "Target"
		local rocketClone = Rocket:Clone()
		game.Debris:AddItem(rocketClone, 30)
		rocketClone.BrickColor = player.TeamColor
		Tracker.Value = rocketClone
		-- Position the rocket clone and launch!
		rocketClone.CFrame = CFrame.new(script.MissilePos.Value.Position + script.MissilePos.Value.CFrame.LookVector * (10 + player.Character.Head.Velocity.Magnitude), script.MissilePos.Value.Position + script.MissilePos.Value.CFrame.LookVector * 10000)
		--rocketClone.Orientation = tool.Handle.Orientation --NOTE: This must be done before assigning Parent
		rocketClone.Velocity = rocketClone.CFrame.lookVector * 500 + player.Character.Head.Velocity --NOTE: This should be done before assigning Parent
		rocketClone.Anchored = false
		rocketClone.Parent = game.Workspace	
		script.MissilePos.Value.Transparency = 1
		wait(0.2)
		rocketClone.Thrust.Target = target
		rocketClone.Thrust:Fire()
		rocketClone.Rocket.Disabled = false
		wait(1)
		script.MissilePos.Value.Transparency = 0
	end
end)
end,
function(script,require)
-- PlaneKit Freeze Fixer
-- samisagetfe

local Seat = script.Parent

Seat.Changed:connect(function(prop)
	wait(1)
	if prop == "Occupant" then
		local humanoid = Seat.Occupant
		if humanoid then
			local player = game:GetService("Players"):GetPlayerFromCharacter(humanoid.Parent)
			if player then
				Seat:SetNetworkOwner(player)
			end
		else
			Seat:SetNetworkOwnershipAuto()
		end
	end
end)
end,
function(script,require)
--Don't modify this script unless you really know what you're doing.

local WaitFor = (function(parent, child_name)
	local found = parent:FindFirstChild(child_name)
	while found == nil do
		parent.ChildAdded:wait()
		found = parent:FindFirstChild(child_name)
		if found then break end
	end
	return found
end)

local last = { neckC1 = nil, rshoC0 = nil, lshoC0 = nil, rhipC0 = nil, lhipC0 = nil }

local ApplyModifications = (function(weld, char)
	local torso = WaitFor(char, "Torso")
	local neck = WaitFor(torso, "Neck")
	local rsho = WaitFor(torso, "Right Shoulder")
	local lsho = WaitFor(torso, "Left Shoulder")
	local rhip = WaitFor(torso, "Right Hip")
	local lhip = WaitFor(torso, "Left Hip")

	local LA = WaitFor(char, "Left Arm")
	local RA = WaitFor(char, "Right Arm")

	local config = script.Parent.Configuration
	local head_ang = config["Head Angle"].Value
	local legs_ang = config["Legs Angle"].Value
	local arms_ang = config["Arms Angle"].Value
	local sit_ang  = config["Sitting Angle"].Value
	local sit_pos  = config["Sitting Position"].Value

	--First adjust sitting position and angle
	--Add 90 to the angle because that's what most people will be expecting.
	--weld.C1 = weld.C1 * CFrame.fromEulerAnglesXYZ(math.rad((sit_ang) + 90), 0, 0)
	
	--weld.C0 = CFrame.new(sit_pos)
	weld.C0 = weld.C0 * CFrame.new(0, 1, 0)

	last.neckC1 = neck.C1
	last.rshoC0 = rsho.C0
	last.lshoC0 = lsho.C0
	last.rhipC0 = rhip.C0
	last.lhipC0 = lhip.C0

	--Now adjust the neck angle.
	neck.C1 = neck.C1 * CFrame.fromEulerAnglesXYZ(math.rad(head_ang), 0, 0)
	

	--Now adjust the arms angle.
	rsho.C0 = rsho.C0 * CFrame.fromEulerAnglesXYZ(0, math.rad(arms_ang), 0)
	lsho.C0 = lsho.C0 * CFrame.fromEulerAnglesXYZ(0, math.rad(-arms_ang), 0)
	--RA.Transparency = 1
	--LA.Transparency = 1
	
	

	--Now the legs
	rhip.C0 = rhip.C0 * CFrame.fromEulerAnglesXYZ(0, 0, math.rad(legs_ang))
	lhip.C0 = lhip.C0 * CFrame.fromEulerAnglesXYZ(0, 0, math.rad(-legs_ang))
end)

local RevertModifications = (function(weld, char)
	--Any modifications done in ApplyModifications have to be reverted here if they
	--change any welds - otherwise people will wonder why their head is pointing the wrong way.

	local torso = WaitFor(char, "Torso")
	local neck = WaitFor(torso, "Neck")
	local rsho = WaitFor(torso, "Right Shoulder")
	local lsho = WaitFor(torso, "Left Shoulder")
	local rhip = WaitFor(torso, "Right Hip")
	local lhip = WaitFor(torso, "Left Hip")
	
	local LA = WaitFor(char, "Left Arm")
	local RA = WaitFor(char, "Right Arm")

	--Now adjust the neck angle.
	neck.C1 = last.neckC1 or CFrame.new()

	rsho.C0 = last.rshoC0 or CFrame.new()
	lsho.C0 = last.lshoC0 or CFrame.new()

	rhip.C0 = last.rhipC0 or CFrame.new()
	lhip.C0 = last.lhipC0 or CFrame.new()
	RA.Transparency = 0
	LA.Transparency = 0

	weld:Destroy()
end)

script.Parent.ChildAdded:connect(function(c)
	if c:IsA("Weld") then
		local character = nil
		if c.Part1 ~= nil and c.Part1.Parent ~= nil and c.Part1.Parent:FindFirstChild("Humanoid") ~= nil then
			character = c.Part1.Parent
		else return end
		ApplyModifications(c, character)
	end
end)

script.Parent.ChildRemoved:connect(function(c)
	if c:IsA("Weld") then
		local character = nil
		if c.Part1 ~= nil and c.Part1.Parent ~= nil and c.Part1.Parent:FindFirstChild("Humanoid") ~= nil then
			character = c.Part1.Parent
		else return end
		RevertModifications(c, character)
	end
end)
end,
function(script,require)
seat = script.Parent.Parent


while wait(0.1) do
if math.clamp(-seat.Velocity.Y/seat.Position.Y*10,0, math.huge) > 4.5 then
	script.Parent.Playing = true
else
	script.Parent.Playing = false
end
end

end,
function(script,require)
local cs = game:GetService("CollectionService")
if script.Parent:IsA("BasePart") then
cs:AddTag(script.Parent, "target")
end
script.Disabled = true
end,
function(script,require)
seat = script.Parent.Parent
while wait() do
local track = seat:FindFirstChildWhichIsA("ObjectValue")
if track ~= nil then
	script.Parent.Playing = true
else
	script.Parent.Playing = false
end
end
end,
function(script,require)
local Seat = script.Parent
local PlaneTool = Seat.Plane
local PlaneMain = Seat.Parent.Parent
local Customize = PlaneMain.Customize
local Crashed = PlaneMain.Crashed
local Player = nil
-----------------------------------------------------------------------------------
function CheckPlayer(Player) --This function checks the player
	if Customize.GroupSpecific.Value then --If the GroupSpecific value is true...
		if (not Player:IsInGroup(Customize.GroupSpecific.GroupID.Value)) then --If the player is not part of the group...
			return false
		end
	end
	return true
end

function GivePlaneTool(Child) --This function puts the tool in the player by using the "SeatWeld"
	if Child.ClassName == "Weld" then
		local Player = game.Players:GetPlayerFromCharacter(Child.Part1.Parent) --This gets the Player
		if Player then
			PlaneMain.Parent = Player.Character --This makes the plane a part of the Player's Character
			Plane = PlaneTool:Clone()
			Plane.Parent = Player.Backpack
			Plane.Main.Disabled = false --This undisables the Main script in the Tool, but the tool also has a fail safe
			Plane.missile_system_server.Disabled = false
			Plane.missile_system_local.Disabled = false
		end
	end
end

function RemovePlaneTool(Child) --This function removes the tool
	if Child.Name == "SeatWeld" then
		local Player = game.Players:GetPlayerFromCharacter(Child.Part1.Parent)
		if Player then
			if Plane then
				Plane.Deselect0.Value = Plane.ToolSelect.Value --This makes the Deselect0 value on the plane tool true, which forces deselection
				wait(0.1) --This gives the tool enough time to activate the function
				Plane:Destroy() --This removes the plane tool
				PlaneMain.Parent = workspace --This puts the plane back into the Planekit folder
			end
		end
	end
end

Seat.ChildAdded:connect(GivePlaneTool) --This activates the "GivePlaneTool" function when you sit on the seat
Seat.ChildRemoved:connect(RemovePlaneTool) --This activates the "RemovePlaneTool" function when you get off the seat
end,
function(script,require)
local throttle = script.Parent.Parent.Parent.Events.Throttle
local engine = script.Parent.Parent.Parent.Events.Engine
local pitch = script.Parent.EngineSound.PlaybackSpeed
local speed = 0
local targetpitch = 0
local pitchoffset = 0

throttle.OnServerEvent:Connect(function(client, val)
	pitchoffset = val
end)

engine.OnServerEvent:Connect(function(client, isStart)
	if isStart  then
	targetpitch = 1
	else
	targetpitch = 0
	end
end)

while wait() do
	speed += math.sign(targetpitch - speed)/500
	script.Parent.EngineSound.PlaybackSpeed = speed + pitchoffset
	script.Parent.EngineSound.Volume += script.Parent.EngineSound.PlaybackSpeed*1.5
end
end,
function(script,require)
--local round = game.ServerStorage.round
local rateOfFire = 22000
local firing = false
script.Parent.Parent.Parent.Events.Gun.OnServerEvent:Connect(function(client, bool)
		firing = bool
		script.Parent.ParticleEmitter.Enabled = bool
		script.Parent.Sound.Playing = bool
end)
while wait(1/rateOfFire*60) do
if firing then
	projectile = game.ServerStorage.Round:Clone()
	projectile.Parent = workspace
	--projectile.Shape = "Ball"
	--projectile.Color = Color3.fromRGB(255,150,150)
	projectile.CFrame = script.Parent.CFrame * CFrame.new(0,0,-10 - script.Parent.Velocity.Magnitude/1.5)
	projectile.Orientation += script.Parent.RotVelocity * 5
	local Velo = Instance.new("BodyVelocity", projectile)
	Velo.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
	Velo.P = 1000
	Velo.Velocity = projectile.CFrame.lookVector.unit * (2000 + script.Parent.Velocity.Magnitude) + Vector3.new(math.random(1,4)-2, math.random(1,4)-2, math.random(1,4)-2)
	--projectile.Velocity = projectile.CFrame.LookVector * (1000 + math.random(1,50)) + script.Parent.Velocity
	game.Debris:AddItem(projectile,10)
	projectile.CanCollide = true
	local new = script.Boom:Clone()
	new.Parent = projectile
	new.Disabled = false
end
end

end,
function(script,require)
--wait(0.8)
local proj = script.Parent
proj.Touched:Connect(function(h)
for i = 0, 1, 0.5 do
	local boom = Instance.new("Explosion",workspace)
	if not h:IsGrounded() then
	boom.Visible = false
	end
	boom.Position = proj.Position + Vector3.new(math.random(1,40)-20, math.random(1,40)-20, math.random(1,40)-20)
	proj:Destroy()
end
end)

while wait() do
proj.BodyVelocity.Velocity -= Vector3.new(0,2,0)
end
end,
function(script,require)
while wait(0.05) do
	script.Parent.Frame.Position = UDim2.new(0.05, 0, (math.floor(script.Parent.Parent.Parent.Orientation.X)/22.5+0.5), 0)
	script.Parent.Rotation = math.floor(script.Parent.Parent.Parent.Orientation.Z)
end




end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Velocity.Magnitude)
end

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Position.Y)
end

end,
function(script,require)
script.Parent.Parent.Parent.Parent.Parent.Events.Throttle.OnServerEvent:Connect(function(client, val)
script.Parent.Text = math.floor(val*100).."%"
end)

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Velocity.Magnitude)
end

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Position.Y)
end

end,
function(script,require)
script.Parent.Parent.Parent.Parent.Parent.Events.Throttle.OnServerEvent:Connect(function(client, val)
script.Parent.Text = math.floor(val*100).."%"
end)

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Position.Y)
end

end,
function(script,require)
script.Parent.Parent.Parent.Parent.Parent.Events.Throttle.OnServerEvent:Connect(function(client, val)
script.Parent.Text = math.floor(val*100).."%"
end)

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Velocity.Magnitude)
end

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Position.Y)
end

end,
function(script,require)
script.Parent.Parent.Parent.Parent.Parent.Events.Throttle.OnServerEvent:Connect(function(client, val)
script.Parent.Text = math.floor(val*100).."%"
end)

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Velocity.Magnitude)
end

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Position.Y)
end

end,
function(script,require)
script.Parent.Parent.Parent.Parent.Parent.Events.Throttle.OnServerEvent:Connect(function(client, val)
script.Parent.Text = math.floor(val*100).."%"
end)

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Velocity.Magnitude)
end

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Position.Y)
end

end,
function(script,require)
script.Parent.Parent.Parent.Parent.Parent.Events.Throttle.OnServerEvent:Connect(function(client, val)
script.Parent.Text = math.floor(val*100).."%"
end)

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Velocity.Magnitude)
end

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Position.Y)
end

end,
function(script,require)
script.Parent.Parent.Parent.Parent.Parent.Events.Throttle.OnServerEvent:Connect(function(client, val)
script.Parent.Text = math.floor(val*100).."%"
end)

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Velocity.Magnitude)
end

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Position.Y)
end

end,
function(script,require)
script.Parent.Parent.Parent.Parent.Parent.Events.Throttle.OnServerEvent:Connect(function(client, val)
script.Parent.Text = math.floor(val*100).."%"
end)

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Velocity.Magnitude)
end

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Position.Y)
end

end,
function(script,require)
script.Parent.Parent.Parent.Parent.Parent.Events.Throttle.OnServerEvent:Connect(function(client, val)
script.Parent.Text = math.floor(val*100).."%"
end)

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Velocity.Magnitude)
end

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Position.Y)
end

end,
function(script,require)
script.Parent.Parent.Parent.Parent.Parent.Events.Throttle.OnServerEvent:Connect(function(client, val)
script.Parent.Text = math.floor(val*100).."%"
end)

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Velocity.Magnitude)
end

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Position.Y)
end

end,
function(script,require)
script.Parent.Parent.Parent.Parent.Parent.Events.Throttle.OnServerEvent:Connect(function(client, val)
script.Parent.Text = math.floor(val*100).."%"
end)

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Velocity.Magnitude)
end

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Position.Y)
end

end,
function(script,require)
script.Parent.Parent.Parent.Parent.Parent.Events.Throttle.OnServerEvent:Connect(function(client, val)
script.Parent.Text = math.floor(val*100).."%"
end)

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Velocity.Magnitude)
end

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Position.Y)
end

end,
function(script,require)
script.Parent.Parent.Parent.Parent.Parent.Events.Throttle.OnServerEvent:Connect(function(client, val)
script.Parent.Text = math.floor(val*100).."%"
end)

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Velocity.Magnitude)
end

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Position.Y)
end

end,
function(script,require)
script.Parent.Parent.Parent.Parent.Parent.Events.Throttle.OnServerEvent:Connect(function(client, val)
script.Parent.Text = math.floor(val*100).."%"
end)

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Velocity.Magnitude)
end

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Position.Y)
end

end,
function(script,require)
script.Parent.Parent.Parent.Parent.Parent.Events.Throttle.OnServerEvent:Connect(function(client, val)
script.Parent.Text = math.floor(val*100).."%"
end)

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Velocity.Magnitude)
end

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Position.Y)
end

end,
function(script,require)
script.Parent.Parent.Parent.Parent.Parent.Events.Throttle.OnServerEvent:Connect(function(client, val)
script.Parent.Text = math.floor(val*100).."%"
end)

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Velocity.Magnitude)
end

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Position.Y)
end

end,
function(script,require)
script.Parent.Parent.Parent.Parent.Parent.Events.Throttle.OnServerEvent:Connect(function(client, val)
script.Parent.Text = math.floor(val*100).."%"
end)

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Velocity.Magnitude)
end

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Position.Y)
end

end,
function(script,require)
script.Parent.Parent.Parent.Parent.Parent.Events.Throttle.OnServerEvent:Connect(function(client, val)
script.Parent.Text = math.floor(val*100).."%"
end)

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Velocity.Magnitude)
end

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Position.Y)
end

end,
function(script,require)
script.Parent.Parent.Parent.Parent.Parent.Events.Throttle.OnServerEvent:Connect(function(client, val)
script.Parent.Text = math.floor(val*100).."%"
end)

end,
function(script,require)
while wait(0.1) do
script.Parent.Text = math.floor(script.Parent.Parent.Parent.Velocity.Magnitude)
end

end,
function(script,require)
evt = script.evt.Value

evt.OnServerEvent:Connect(function(cl, val)
if val > 0.9 then
script.Parent.Sound.PlaybackSpeed = math.clamp((val-0.9)*20+0.4, 0, 1)
else
script.Parent.Sound.PlaybackSpeed = math.clamp((val-0.2)/1.5,0,1)
end
end)

end,
function(script,require)
script.Parent.Parent.Parent.Events.Smoke.OnServerEvent:Connect(function()
	local flare = game.ServerStorage:FindFirstChild("Flare"):clone()
	flare.Anchored = false
	flare.Parent = workspace
	flare.Position = script.Parent.Position
	wait()
	flare.Orientation = script.Parent.Orientation
	flare.Velocity = script.Parent.Velocity+script.Parent.CFrame.LookVector*50+Vector3.new(math.random(1,5),math.random(1,5),math.random(1,5))
	flare.flare.Disabled = false
end)

end,
function(script,require)
local Event = script.Parent.Parent.Parent.Parent.Parent.Events.Elevators
Event.OnServerEvent:Connect(function(client, pitch)
	script.Parent.DesiredAngle = math.rad(pitch)*20
end)
end,
function(script,require)
-- Created by Quenty (@Quenty, follow me on twitter).
-- Should work with only ONE copy, seamlessly with weapons, trains, et cetera.
-- Parts should be ANCHORED before use. It will, however, store relatives values and so when tools are reparented, it'll fix them.

--[[ INSTRUCTIONS
- Place in the model
- Make sure model is anchored
- That's it. It will weld the model and all children. 

THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 

This script is designed to be used is a regular script. In a local script it will weld, but it will not attempt to handle ancestory changes. 
]]

--[[ DOCUMENTATION
- Will work in tools. If ran more than once it will not create more than one weld.  This is especially useful for tools that are dropped and then picked up again.
- Will work in PBS servers
- Will work as long as it starts out with the part anchored
- Stores the relative CFrame as a CFrame value
- Takes careful measure to reduce lag by not having a joint set off or affected by the parts offset from origin
- Utilizes a recursive algorith to find all parts in the model
- Will reweld on script reparent if the script is initially parented to a tool.
- Welds as fast as possible
]]

-- qPerfectionWeld.lua
-- Created 10/6/2014
-- Author: Quenty
-- Version 1.0.3

-- Updated 10/14/2014 - Updated to 1.0.1
--- Bug fix with existing ROBLOX welds ? Repro by asimo3089

-- Updated 10/14/2014 - Updated to 1.0.2
--- Fixed bug fix. 

-- Updated 10/14/2014 - Updated to 1.0.3
--- Now handles joints semi-acceptably. May be rather hacky with some joints. :/

local NEVER_BREAK_JOINTS = false -- If you set this to true it will never break joints (this can create some welding issues, but can save stuff like hinges).


local function CallOnChildren(Instance, FunctionToCall)
	-- Calls a function on each of the children of a certain object, using recursion.  

	FunctionToCall(Instance)

	for _, Child in next, Instance:GetChildren() do
		CallOnChildren(Child, FunctionToCall)
	end
end

local function GetNearestParent(Instance, ClassName)
	-- Returns the nearest parent of a certain class, or returns nil

	local Ancestor = Instance
	repeat
		Ancestor = Ancestor.Parent
		if Ancestor == nil then
			return nil
		end
	until Ancestor:IsA(ClassName)

	return Ancestor
end

local function GetBricks(StartInstance)
	local List = {}

	-- if StartInstance:IsA("BasePart") then
	-- 	List[#List+1] = StartInstance
	-- end

	CallOnChildren(StartInstance, function(Item)
		if Item:IsA("BasePart") then
			List[#List+1] = Item;
		end
	end)

	return List
end

local function Modify(Instance, Values)
	-- Modifies an Instance by using a table.  

	assert(type(Values) == "table", "Values is not a table");

	for Index, Value in next, Values do
		if type(Index) == "number" then
			Value.Parent = Instance
		else
			Instance[Index] = Value
		end
	end
	return Instance
end

local function Make(ClassType, Properties)
	-- Using a syntax hack to create a nice way to Make new items.  

	return Modify(Instance.new(ClassType), Properties)
end

local Surfaces = {"TopSurface", "BottomSurface", "LeftSurface", "RightSurface", "FrontSurface", "BackSurface"}
local HingSurfaces = {"Hinge", "Motor", "SteppingMotor"}

local function HasWheelJoint(Part)
	for _, SurfaceName in pairs(Surfaces) do
		for _, HingSurfaceName in pairs(HingSurfaces) do
			if Part[SurfaceName].Name == HingSurfaceName then
				return true
			end
		end
	end
	
	return false
end

local function ShouldBreakJoints(Part)
	--- We do not want to break joints of wheels/hinges. This takes the utmost care to not do this. There are
	--  definitely some edge cases. 

	if NEVER_BREAK_JOINTS then
		return false
	end
	
	if HasWheelJoint(Part) then
		return false
	end
	
	local Connected = Part:GetConnectedParts()
	
	if #Connected == 1 then
		return false
	end
	
	for _, Item in pairs(Connected) do
		if HasWheelJoint(Item) then
			return false
		elseif not Item:IsDescendantOf(script.Parent) then
			return false
		end
	end
	
	return true
end

local function WeldTogether(Part0, Part1, JointType, WeldParent)
	--- Weld's 2 parts together
	-- @param Part0 The first part
	-- @param Part1 The second part (Dependent part most of the time).
	-- @param [JointType] The type of joint. Defaults to weld.
	-- @param [WeldParent] Parent of the weld, Defaults to Part0 (so GC is better).
	-- @return The weld created.

	JointType = JointType or "Weld"
	local RelativeValue = Part1:FindFirstChild("qRelativeCFrameWeldValue")
	
	local NewWeld = Part1:FindFirstChild("qCFrameWeldThingy") or Instance.new(JointType)
	Modify(NewWeld, {
		Name = "qCFrameWeldThingy";
		Part0  = Part0;
		Part1  = Part1;
		C0     = CFrame.new();--Part0.CFrame:inverse();
		C1     = RelativeValue and RelativeValue.Value or Part1.CFrame:toObjectSpace(Part0.CFrame); --Part1.CFrame:inverse() * Part0.CFrame;-- Part1.CFrame:inverse();
		Parent = Part1;
	})

	if not RelativeValue then
		RelativeValue = Make("CFrameValue", {
			Parent     = Part1;
			Name       = "qRelativeCFrameWeldValue";
			Archivable = true;
			Value      = NewWeld.C1;
		})
	end

	return NewWeld
end

local function WeldParts(Parts, MainPart, JointType, DoNotUnanchor)
	-- @param Parts The Parts to weld. Should be anchored to prevent really horrible results.
	-- @param MainPart The part to weld the model to (can be in the model).
	-- @param [JointType] The type of joint. Defaults to weld. 
	-- @parm DoNotUnanchor Boolean, if true, will not unachor the model after cmopletion.
	
	for _, Part in pairs(Parts) do
		if ShouldBreakJoints(Part) then
			Part:BreakJoints()
		end
	end
	
	for _, Part in pairs(Parts) do
		if Part ~= MainPart then
			WeldTogether(MainPart, Part, JointType, MainPart)
		end
	end

	if not DoNotUnanchor then
		for _, Part in pairs(Parts) do
			Part.Anchored = false
		end
		MainPart.Anchored = false
	end
end

local function PerfectionWeld()	
	local Tool = GetNearestParent(script, "Tool")

	local Parts = GetBricks(script.Parent)
	local PrimaryPart = Tool and Tool:FindFirstChild("Handle") and Tool.Handle:IsA("BasePart") and Tool.Handle or script.Parent:IsA("Model") and script.Parent.PrimaryPart or Parts[1]

	if PrimaryPart then
		WeldParts(Parts, PrimaryPart, "Weld", false)
	else
		warn("qWeld - Unable to weld part")
	end
	
	return Tool
end

local Tool = PerfectionWeld()


if Tool and script.ClassName == "Script" then
	--- Don't bother with local scripts

	script.Parent.AncestryChanged:connect(function()
		PerfectionWeld()
	end)
end

-- Created by Quenty (@Quenty, follow me on twitter).

end,
function(script,require)
local Event = script.Parent.Parent.Parent.Parent.Parent.Events.Ailerons
Event.OnServerEvent:Connect(function(client, pitch)
	script.Parent.DesiredAngle = math.rad(pitch*-20)
end)
end,
function(script,require)
local Event = script.Parent.Parent.Parent.Parent.Parent.Events.Ailerons
Event.OnServerEvent:Connect(function(client, pitch)
	script.Parent.DesiredAngle = math.rad(pitch*20)
end)
end,
function(script,require)
-- Created by Quenty (@Quenty, follow me on twitter).
-- Should work with only ONE copy, seamlessly with weapons, trains, et cetera.
-- Parts should be ANCHORED before use. It will, however, store relatives values and so when tools are reparented, it'll fix them.

--[[ INSTRUCTIONS
- Place in the model
- Make sure model is anchored
- That's it. It will weld the model and all children. 

THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 

This script is designed to be used is a regular script. In a local script it will weld, but it will not attempt to handle ancestory changes. 
]]

--[[ DOCUMENTATION
- Will work in tools. If ran more than once it will not create more than one weld.  This is especially useful for tools that are dropped and then picked up again.
- Will work in PBS servers
- Will work as long as it starts out with the part anchored
- Stores the relative CFrame as a CFrame value
- Takes careful measure to reduce lag by not having a joint set off or affected by the parts offset from origin
- Utilizes a recursive algorith to find all parts in the model
- Will reweld on script reparent if the script is initially parented to a tool.
- Welds as fast as possible
]]

-- qPerfectionWeld.lua
-- Created 10/6/2014
-- Author: Quenty
-- Version 1.0.3

-- Updated 10/14/2014 - Updated to 1.0.1
--- Bug fix with existing ROBLOX welds ? Repro by asimo3089

-- Updated 10/14/2014 - Updated to 1.0.2
--- Fixed bug fix. 

-- Updated 10/14/2014 - Updated to 1.0.3
--- Now handles joints semi-acceptably. May be rather hacky with some joints. :/

local NEVER_BREAK_JOINTS = false -- If you set this to true it will never break joints (this can create some welding issues, but can save stuff like hinges).


local function CallOnChildren(Instance, FunctionToCall)
	-- Calls a function on each of the children of a certain object, using recursion.  

	FunctionToCall(Instance)

	for _, Child in next, Instance:GetChildren() do
		CallOnChildren(Child, FunctionToCall)
	end
end

local function GetNearestParent(Instance, ClassName)
	-- Returns the nearest parent of a certain class, or returns nil

	local Ancestor = Instance
	repeat
		Ancestor = Ancestor.Parent
		if Ancestor == nil then
			return nil
		end
	until Ancestor:IsA(ClassName)

	return Ancestor
end

local function GetBricks(StartInstance)
	local List = {}

	-- if StartInstance:IsA("BasePart") then
	-- 	List[#List+1] = StartInstance
	-- end

	CallOnChildren(StartInstance, function(Item)
		if Item:IsA("BasePart") then
			List[#List+1] = Item;
		end
	end)

	return List
end

local function Modify(Instance, Values)
	-- Modifies an Instance by using a table.  

	assert(type(Values) == "table", "Values is not a table");

	for Index, Value in next, Values do
		if type(Index) == "number" then
			Value.Parent = Instance
		else
			Instance[Index] = Value
		end
	end
	return Instance
end

local function Make(ClassType, Properties)
	-- Using a syntax hack to create a nice way to Make new items.  

	return Modify(Instance.new(ClassType), Properties)
end

local Surfaces = {"TopSurface", "BottomSurface", "LeftSurface", "RightSurface", "FrontSurface", "BackSurface"}
local HingSurfaces = {"Hinge", "Motor", "SteppingMotor"}

local function HasWheelJoint(Part)
	for _, SurfaceName in pairs(Surfaces) do
		for _, HingSurfaceName in pairs(HingSurfaces) do
			if Part[SurfaceName].Name == HingSurfaceName then
				return true
			end
		end
	end
	
	return false
end

local function ShouldBreakJoints(Part)
	--- We do not want to break joints of wheels/hinges. This takes the utmost care to not do this. There are
	--  definitely some edge cases. 

	if NEVER_BREAK_JOINTS then
		return false
	end
	
	if HasWheelJoint(Part) then
		return false
	end
	
	local Connected = Part:GetConnectedParts()
	
	if #Connected == 1 then
		return false
	end
	
	for _, Item in pairs(Connected) do
		if HasWheelJoint(Item) then
			return false
		elseif not Item:IsDescendantOf(script.Parent) then
			return false
		end
	end
	
	return true
end

local function WeldTogether(Part0, Part1, JointType, WeldParent)
	--- Weld's 2 parts together
	-- @param Part0 The first part
	-- @param Part1 The second part (Dependent part most of the time).
	-- @param [JointType] The type of joint. Defaults to weld.
	-- @param [WeldParent] Parent of the weld, Defaults to Part0 (so GC is better).
	-- @return The weld created.

	JointType = JointType or "Weld"
	local RelativeValue = Part1:FindFirstChild("qRelativeCFrameWeldValue")
	
	local NewWeld = Part1:FindFirstChild("qCFrameWeldThingy") or Instance.new(JointType)
	Modify(NewWeld, {
		Name = "qCFrameWeldThingy";
		Part0  = Part0;
		Part1  = Part1;
		C0     = CFrame.new();--Part0.CFrame:inverse();
		C1     = RelativeValue and RelativeValue.Value or Part1.CFrame:toObjectSpace(Part0.CFrame); --Part1.CFrame:inverse() * Part0.CFrame;-- Part1.CFrame:inverse();
		Parent = Part1;
	})

	if not RelativeValue then
		RelativeValue = Make("CFrameValue", {
			Parent     = Part1;
			Name       = "qRelativeCFrameWeldValue";
			Archivable = true;
			Value      = NewWeld.C1;
		})
	end

	return NewWeld
end

local function WeldParts(Parts, MainPart, JointType, DoNotUnanchor)
	-- @param Parts The Parts to weld. Should be anchored to prevent really horrible results.
	-- @param MainPart The part to weld the model to (can be in the model).
	-- @param [JointType] The type of joint. Defaults to weld. 
	-- @parm DoNotUnanchor Boolean, if true, will not unachor the model after cmopletion.
	
	for _, Part in pairs(Parts) do
		if ShouldBreakJoints(Part) then
			Part:BreakJoints()
		end
	end
	
	for _, Part in pairs(Parts) do
		if Part ~= MainPart then
			WeldTogether(MainPart, Part, JointType, MainPart)
		end
	end

	if not DoNotUnanchor then
		for _, Part in pairs(Parts) do
			Part.Anchored = false
		end
		MainPart.Anchored = false
	end
end

local function PerfectionWeld()	
	local Tool = GetNearestParent(script, "Tool")

	local Parts = GetBricks(script.Parent)
	local PrimaryPart = Tool and Tool:FindFirstChild("Handle") and Tool.Handle:IsA("BasePart") and Tool.Handle or script.Parent:IsA("Model") and script.Parent.PrimaryPart or Parts[1]

	if PrimaryPart then
		WeldParts(Parts, PrimaryPart, "Weld", false)
	else
		warn("qWeld - Unable to weld part")
	end
	
	return Tool
end

local Tool = PerfectionWeld()


if Tool and script.ClassName == "Script" then
	--- Don't bother with local scripts

	script.Parent.AncestryChanged:connect(function()
		PerfectionWeld()
	end)
end

-- Created by Quenty (@Quenty, follow me on twitter).

end,
function(script,require)
-- Created by Quenty (@Quenty, follow me on twitter).
-- Should work with only ONE copy, seamlessly with weapons, trains, et cetera.
-- Parts should be ANCHORED before use. It will, however, store relatives values and so when tools are reparented, it'll fix them.

--[[ INSTRUCTIONS
- Place in the model
- Make sure model is anchored
- That's it. It will weld the model and all children. 

THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 

This script is designed to be used is a regular script. In a local script it will weld, but it will not attempt to handle ancestory changes. 
]]

--[[ DOCUMENTATION
- Will work in tools. If ran more than once it will not create more than one weld.  This is especially useful for tools that are dropped and then picked up again.
- Will work in PBS servers
- Will work as long as it starts out with the part anchored
- Stores the relative CFrame as a CFrame value
- Takes careful measure to reduce lag by not having a joint set off or affected by the parts offset from origin
- Utilizes a recursive algorith to find all parts in the model
- Will reweld on script reparent if the script is initially parented to a tool.
- Welds as fast as possible
]]

-- qPerfectionWeld.lua
-- Created 10/6/2014
-- Author: Quenty
-- Version 1.0.3

-- Updated 10/14/2014 - Updated to 1.0.1
--- Bug fix with existing ROBLOX welds ? Repro by asimo3089

-- Updated 10/14/2014 - Updated to 1.0.2
--- Fixed bug fix. 

-- Updated 10/14/2014 - Updated to 1.0.3
--- Now handles joints semi-acceptably. May be rather hacky with some joints. :/

local NEVER_BREAK_JOINTS = false -- If you set this to true it will never break joints (this can create some welding issues, but can save stuff like hinges).


local function CallOnChildren(Instance, FunctionToCall)
	-- Calls a function on each of the children of a certain object, using recursion.  

	FunctionToCall(Instance)

	for _, Child in next, Instance:GetChildren() do
		CallOnChildren(Child, FunctionToCall)
	end
end

local function GetNearestParent(Instance, ClassName)
	-- Returns the nearest parent of a certain class, or returns nil

	local Ancestor = Instance
	repeat
		Ancestor = Ancestor.Parent
		if Ancestor == nil then
			return nil
		end
	until Ancestor:IsA(ClassName)

	return Ancestor
end

local function GetBricks(StartInstance)
	local List = {}

	-- if StartInstance:IsA("BasePart") then
	-- 	List[#List+1] = StartInstance
	-- end

	CallOnChildren(StartInstance, function(Item)
		if Item:IsA("BasePart") then
			List[#List+1] = Item;
		end
	end)

	return List
end

local function Modify(Instance, Values)
	-- Modifies an Instance by using a table.  

	assert(type(Values) == "table", "Values is not a table");

	for Index, Value in next, Values do
		if type(Index) == "number" then
			Value.Parent = Instance
		else
			Instance[Index] = Value
		end
	end
	return Instance
end

local function Make(ClassType, Properties)
	-- Using a syntax hack to create a nice way to Make new items.  

	return Modify(Instance.new(ClassType), Properties)
end

local Surfaces = {"TopSurface", "BottomSurface", "LeftSurface", "RightSurface", "FrontSurface", "BackSurface"}
local HingSurfaces = {"Hinge", "Motor", "SteppingMotor"}

local function HasWheelJoint(Part)
	for _, SurfaceName in pairs(Surfaces) do
		for _, HingSurfaceName in pairs(HingSurfaces) do
			if Part[SurfaceName].Name == HingSurfaceName then
				return true
			end
		end
	end
	
	return false
end

local function ShouldBreakJoints(Part)
	--- We do not want to break joints of wheels/hinges. This takes the utmost care to not do this. There are
	--  definitely some edge cases. 

	if NEVER_BREAK_JOINTS then
		return false
	end
	
	if HasWheelJoint(Part) then
		return false
	end
	
	local Connected = Part:GetConnectedParts()
	
	if #Connected == 1 then
		return false
	end
	
	for _, Item in pairs(Connected) do
		if HasWheelJoint(Item) then
			return false
		elseif not Item:IsDescendantOf(script.Parent) then
			return false
		end
	end
	
	return true
end

local function WeldTogether(Part0, Part1, JointType, WeldParent)
	--- Weld's 2 parts together
	-- @param Part0 The first part
	-- @param Part1 The second part (Dependent part most of the time).
	-- @param [JointType] The type of joint. Defaults to weld.
	-- @param [WeldParent] Parent of the weld, Defaults to Part0 (so GC is better).
	-- @return The weld created.

	JointType = JointType or "Weld"
	local RelativeValue = Part1:FindFirstChild("qRelativeCFrameWeldValue")
	
	local NewWeld = Part1:FindFirstChild("qCFrameWeldThingy") or Instance.new(JointType)
	Modify(NewWeld, {
		Name = "qCFrameWeldThingy";
		Part0  = Part0;
		Part1  = Part1;
		C0     = CFrame.new();--Part0.CFrame:inverse();
		C1     = RelativeValue and RelativeValue.Value or Part1.CFrame:toObjectSpace(Part0.CFrame); --Part1.CFrame:inverse() * Part0.CFrame;-- Part1.CFrame:inverse();
		Parent = Part1;
	})

	if not RelativeValue then
		RelativeValue = Make("CFrameValue", {
			Parent     = Part1;
			Name       = "qRelativeCFrameWeldValue";
			Archivable = true;
			Value      = NewWeld.C1;
		})
	end

	return NewWeld
end

local function WeldParts(Parts, MainPart, JointType, DoNotUnanchor)
	-- @param Parts The Parts to weld. Should be anchored to prevent really horrible results.
	-- @param MainPart The part to weld the model to (can be in the model).
	-- @param [JointType] The type of joint. Defaults to weld. 
	-- @parm DoNotUnanchor Boolean, if true, will not unachor the model after cmopletion.
	
	for _, Part in pairs(Parts) do
		if ShouldBreakJoints(Part) then
			Part:BreakJoints()
		end
	end
	
	for _, Part in pairs(Parts) do
		if Part ~= MainPart then
			WeldTogether(MainPart, Part, JointType, MainPart)
		end
	end

	if not DoNotUnanchor then
		for _, Part in pairs(Parts) do
			Part.Anchored = false
		end
		MainPart.Anchored = false
	end
end

local function PerfectionWeld()	
	local Tool = GetNearestParent(script, "Tool")

	local Parts = GetBricks(script.Parent)
	local PrimaryPart = Tool and Tool:FindFirstChild("Handle") and Tool.Handle:IsA("BasePart") and Tool.Handle or script.Parent:IsA("Model") and script.Parent.PrimaryPart or Parts[1]

	if PrimaryPart then
		WeldParts(Parts, PrimaryPart, "Weld", false)
	else
		warn("qWeld - Unable to weld part")
	end
	
	return Tool
end

local Tool = PerfectionWeld()


if Tool and script.ClassName == "Script" then
	--- Don't bother with local scripts

	script.Parent.AncestryChanged:connect(function()
		PerfectionWeld()
	end)
end

-- Created by Quenty (@Quenty, follow me on twitter).

end,
function(script,require)
local Event = script.Parent.Parent.Parent.Events.Canopy
Event.OnServerEvent:Connect(function()
	if script.Parent.p.Motor.DesiredAngle == 0  then
		script.Parent.p.Motor.DesiredAngle = 0.55
	else
		script.Parent.p.Motor.DesiredAngle = 0
	end
end)
end,
function(script,require)
-- Created by Quenty (@Quenty, follow me on twitter).
-- Should work with only ONE copy, seamlessly with weapons, trains, et cetera.
-- Parts should be ANCHORED before use. It will, however, store relatives values and so when tools are reparented, it'll fix them.

--[[ INSTRUCTIONS
- Place in the model
- Make sure model is anchored
- That's it. It will weld the model and all children. 

THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 

This script is designed to be used is a regular script. In a local script it will weld, but it will not attempt to handle ancestory changes. 
]]

--[[ DOCUMENTATION
- Will work in tools. If ran more than once it will not create more than one weld.  This is especially useful for tools that are dropped and then picked up again.
- Will work in PBS servers
- Will work as long as it starts out with the part anchored
- Stores the relative CFrame as a CFrame value
- Takes careful measure to reduce lag by not having a joint set off or affected by the parts offset from origin
- Utilizes a recursive algorith to find all parts in the model
- Will reweld on script reparent if the script is initially parented to a tool.
- Welds as fast as possible
]]

-- qPerfectionWeld.lua
-- Created 10/6/2014
-- Author: Quenty
-- Version 1.0.3

-- Updated 10/14/2014 - Updated to 1.0.1
--- Bug fix with existing ROBLOX welds ? Repro by asimo3089

-- Updated 10/14/2014 - Updated to 1.0.2
--- Fixed bug fix. 

-- Updated 10/14/2014 - Updated to 1.0.3
--- Now handles joints semi-acceptably. May be rather hacky with some joints. :/

local NEVER_BREAK_JOINTS = false -- If you set this to true it will never break joints (this can create some welding issues, but can save stuff like hinges).


local function CallOnChildren(Instance, FunctionToCall)
	-- Calls a function on each of the children of a certain object, using recursion.  

	FunctionToCall(Instance)

	for _, Child in next, Instance:GetChildren() do
		CallOnChildren(Child, FunctionToCall)
	end
end

local function GetNearestParent(Instance, ClassName)
	-- Returns the nearest parent of a certain class, or returns nil

	local Ancestor = Instance
	repeat
		Ancestor = Ancestor.Parent
		if Ancestor == nil then
			return nil
		end
	until Ancestor:IsA(ClassName)

	return Ancestor
end

local function GetBricks(StartInstance)
	local List = {}

	-- if StartInstance:IsA("BasePart") then
	-- 	List[#List+1] = StartInstance
	-- end

	CallOnChildren(StartInstance, function(Item)
		if Item:IsA("BasePart") then
			List[#List+1] = Item;
		end
	end)

	return List
end

local function Modify(Instance, Values)
	-- Modifies an Instance by using a table.  

	assert(type(Values) == "table", "Values is not a table");

	for Index, Value in next, Values do
		if type(Index) == "number" then
			Value.Parent = Instance
		else
			Instance[Index] = Value
		end
	end
	return Instance
end

local function Make(ClassType, Properties)
	-- Using a syntax hack to create a nice way to Make new items.  

	return Modify(Instance.new(ClassType), Properties)
end

local Surfaces = {"TopSurface", "BottomSurface", "LeftSurface", "RightSurface", "FrontSurface", "BackSurface"}
local HingSurfaces = {"Hinge", "Motor", "SteppingMotor"}

local function HasWheelJoint(Part)
	for _, SurfaceName in pairs(Surfaces) do
		for _, HingSurfaceName in pairs(HingSurfaces) do
			if Part[SurfaceName].Name == HingSurfaceName then
				return true
			end
		end
	end
	
	return false
end

local function ShouldBreakJoints(Part)
	--- We do not want to break joints of wheels/hinges. This takes the utmost care to not do this. There are
	--  definitely some edge cases. 

	if NEVER_BREAK_JOINTS then
		return false
	end
	
	if HasWheelJoint(Part) then
		return false
	end
	
	local Connected = Part:GetConnectedParts()
	
	if #Connected == 1 then
		return false
	end
	
	for _, Item in pairs(Connected) do
		if HasWheelJoint(Item) then
			return false
		elseif not Item:IsDescendantOf(script.Parent) then
			return false
		end
	end
	
	return true
end

local function WeldTogether(Part0, Part1, JointType, WeldParent)
	--- Weld's 2 parts together
	-- @param Part0 The first part
	-- @param Part1 The second part (Dependent part most of the time).
	-- @param [JointType] The type of joint. Defaults to weld.
	-- @param [WeldParent] Parent of the weld, Defaults to Part0 (so GC is better).
	-- @return The weld created.

	JointType = JointType or "Weld"
	local RelativeValue = Part1:FindFirstChild("qRelativeCFrameWeldValue")
	
	local NewWeld = Part1:FindFirstChild("qCFrameWeldThingy") or Instance.new(JointType)
	Modify(NewWeld, {
		Name = "qCFrameWeldThingy";
		Part0  = Part0;
		Part1  = Part1;
		C0     = CFrame.new();--Part0.CFrame:inverse();
		C1     = RelativeValue and RelativeValue.Value or Part1.CFrame:toObjectSpace(Part0.CFrame); --Part1.CFrame:inverse() * Part0.CFrame;-- Part1.CFrame:inverse();
		Parent = Part1;
	})

	if not RelativeValue then
		RelativeValue = Make("CFrameValue", {
			Parent     = Part1;
			Name       = "qRelativeCFrameWeldValue";
			Archivable = true;
			Value      = NewWeld.C1;
		})
	end

	return NewWeld
end

local function WeldParts(Parts, MainPart, JointType, DoNotUnanchor)
	-- @param Parts The Parts to weld. Should be anchored to prevent really horrible results.
	-- @param MainPart The part to weld the model to (can be in the model).
	-- @param [JointType] The type of joint. Defaults to weld. 
	-- @parm DoNotUnanchor Boolean, if true, will not unachor the model after cmopletion.
	
	for _, Part in pairs(Parts) do
		if ShouldBreakJoints(Part) then
			Part:BreakJoints()
		end
	end
	
	for _, Part in pairs(Parts) do
		if Part ~= MainPart then
			WeldTogether(MainPart, Part, JointType, MainPart)
		end
	end

	if not DoNotUnanchor then
		for _, Part in pairs(Parts) do
			Part.Anchored = false
		end
		MainPart.Anchored = false
	end
end

local function PerfectionWeld()	
	local Tool = GetNearestParent(script, "Tool")

	local Parts = GetBricks(script.Parent)
	local PrimaryPart = Tool and Tool:FindFirstChild("Handle") and Tool.Handle:IsA("BasePart") and Tool.Handle or script.Parent:IsA("Model") and script.Parent.PrimaryPart or Parts[1]

	if PrimaryPart then
		WeldParts(Parts, PrimaryPart, "Weld", false)
	else
		warn("qWeld - Unable to weld part")
	end
	
	return Tool
end

local Tool = PerfectionWeld()


if Tool and script.ClassName == "Script" then
	--- Don't bother with local scripts

	script.Parent.AncestryChanged:connect(function()
		PerfectionWeld()
	end)
end

-- Created by Quenty (@Quenty, follow me on twitter).

end,
function(script,require)
-- Created by Quenty (@Quenty, follow me on twitter).
-- Should work with only ONE copy, seamlessly with weapons, trains, et cetera.
-- Parts should be ANCHORED before use. It will, however, store relatives values and so when tools are reparented, it'll fix them.

--[[ INSTRUCTIONS
- Place in the model
- Make sure model is anchored
- That's it. It will weld the model and all children. 

THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 

This script is designed to be used is a regular script. In a local script it will weld, but it will not attempt to handle ancestory changes. 
]]

--[[ DOCUMENTATION
- Will work in tools. If ran more than once it will not create more than one weld.  This is especially useful for tools that are dropped and then picked up again.
- Will work in PBS servers
- Will work as long as it starts out with the part anchored
- Stores the relative CFrame as a CFrame value
- Takes careful measure to reduce lag by not having a joint set off or affected by the parts offset from origin
- Utilizes a recursive algorith to find all parts in the model
- Will reweld on script reparent if the script is initially parented to a tool.
- Welds as fast as possible
]]

-- qPerfectionWeld.lua
-- Created 10/6/2014
-- Author: Quenty
-- Version 1.0.3

-- Updated 10/14/2014 - Updated to 1.0.1
--- Bug fix with existing ROBLOX welds ? Repro by asimo3089

-- Updated 10/14/2014 - Updated to 1.0.2
--- Fixed bug fix. 

-- Updated 10/14/2014 - Updated to 1.0.3
--- Now handles joints semi-acceptably. May be rather hacky with some joints. :/

local NEVER_BREAK_JOINTS = false -- If you set this to true it will never break joints (this can create some welding issues, but can save stuff like hinges).


local function CallOnChildren(Instance, FunctionToCall)
	-- Calls a function on each of the children of a certain object, using recursion.  

	FunctionToCall(Instance)

	for _, Child in next, Instance:GetChildren() do
		CallOnChildren(Child, FunctionToCall)
	end
end

local function GetNearestParent(Instance, ClassName)
	-- Returns the nearest parent of a certain class, or returns nil

	local Ancestor = Instance
	repeat
		Ancestor = Ancestor.Parent
		if Ancestor == nil then
			return nil
		end
	until Ancestor:IsA(ClassName)

	return Ancestor
end

local function GetBricks(StartInstance)
	local List = {}

	-- if StartInstance:IsA("BasePart") then
	-- 	List[#List+1] = StartInstance
	-- end

	CallOnChildren(StartInstance, function(Item)
		if Item:IsA("BasePart") then
			List[#List+1] = Item;
		end
	end)

	return List
end

local function Modify(Instance, Values)
	-- Modifies an Instance by using a table.  

	assert(type(Values) == "table", "Values is not a table");

	for Index, Value in next, Values do
		if type(Index) == "number" then
			Value.Parent = Instance
		else
			Instance[Index] = Value
		end
	end
	return Instance
end

local function Make(ClassType, Properties)
	-- Using a syntax hack to create a nice way to Make new items.  

	return Modify(Instance.new(ClassType), Properties)
end

local Surfaces = {"TopSurface", "BottomSurface", "LeftSurface", "RightSurface", "FrontSurface", "BackSurface"}
local HingSurfaces = {"Hinge", "Motor", "SteppingMotor"}

local function HasWheelJoint(Part)
	for _, SurfaceName in pairs(Surfaces) do
		for _, HingSurfaceName in pairs(HingSurfaces) do
			if Part[SurfaceName].Name == HingSurfaceName then
				return true
			end
		end
	end
	
	return false
end

local function ShouldBreakJoints(Part)
	--- We do not want to break joints of wheels/hinges. This takes the utmost care to not do this. There are
	--  definitely some edge cases. 

	if NEVER_BREAK_JOINTS then
		return false
	end
	
	if HasWheelJoint(Part) then
		return false
	end
	
	local Connected = Part:GetConnectedParts()
	
	if #Connected == 1 then
		return false
	end
	
	for _, Item in pairs(Connected) do
		if HasWheelJoint(Item) then
			return false
		elseif not Item:IsDescendantOf(script.Parent) then
			return false
		end
	end
	
	return true
end

local function WeldTogether(Part0, Part1, JointType, WeldParent)
	--- Weld's 2 parts together
	-- @param Part0 The first part
	-- @param Part1 The second part (Dependent part most of the time).
	-- @param [JointType] The type of joint. Defaults to weld.
	-- @param [WeldParent] Parent of the weld, Defaults to Part0 (so GC is better).
	-- @return The weld created.

	JointType = JointType or "Weld"
	local RelativeValue = Part1:FindFirstChild("qRelativeCFrameWeldValue")
	
	local NewWeld = Part1:FindFirstChild("qCFrameWeldThingy") or Instance.new(JointType)
	Modify(NewWeld, {
		Name = "qCFrameWeldThingy";
		Part0  = Part0;
		Part1  = Part1;
		C0     = CFrame.new();--Part0.CFrame:inverse();
		C1     = RelativeValue and RelativeValue.Value or Part1.CFrame:toObjectSpace(Part0.CFrame); --Part1.CFrame:inverse() * Part0.CFrame;-- Part1.CFrame:inverse();
		Parent = Part1;
	})

	if not RelativeValue then
		RelativeValue = Make("CFrameValue", {
			Parent     = Part1;
			Name       = "qRelativeCFrameWeldValue";
			Archivable = true;
			Value      = NewWeld.C1;
		})
	end

	return NewWeld
end

local function WeldParts(Parts, MainPart, JointType, DoNotUnanchor)
	-- @param Parts The Parts to weld. Should be anchored to prevent really horrible results.
	-- @param MainPart The part to weld the model to (can be in the model).
	-- @param [JointType] The type of joint. Defaults to weld. 
	-- @parm DoNotUnanchor Boolean, if true, will not unachor the model after cmopletion.
	
	for _, Part in pairs(Parts) do
		if ShouldBreakJoints(Part) then
			Part:BreakJoints()
		end
	end
	
	for _, Part in pairs(Parts) do
		if Part ~= MainPart then
			WeldTogether(MainPart, Part, JointType, MainPart)
		end
	end

	if not DoNotUnanchor then
		for _, Part in pairs(Parts) do
			Part.Anchored = false
		end
		MainPart.Anchored = false
	end
end

local function PerfectionWeld()	
	local Tool = GetNearestParent(script, "Tool")

	local Parts = GetBricks(script.Parent)
	local PrimaryPart = Tool and Tool:FindFirstChild("Handle") and Tool.Handle:IsA("BasePart") and Tool.Handle or script.Parent:IsA("Model") and script.Parent.PrimaryPart or Parts[1]

	if PrimaryPart then
		WeldParts(Parts, PrimaryPart, "Weld", false)
	else
		warn("qWeld - Unable to weld part")
	end
	
	return Tool
end

local Tool = PerfectionWeld()


if Tool and script.ClassName == "Script" then
	--- Don't bother with local scripts

	script.Parent.AncestryChanged:connect(function()
		PerfectionWeld()
	end)
end

-- Created by Quenty (@Quenty, follow me on twitter).

end,
function(script,require)
-- Created by Quenty (@Quenty, follow me on twitter).
-- Should work with only ONE copy, seamlessly with weapons, trains, et cetera.
-- Parts should be ANCHORED before use. It will, however, store relatives values and so when tools are reparented, it'll fix them.

--[[ INSTRUCTIONS
- Place in the model
- Make sure model is anchored
- That's it. It will weld the model and all children. 

THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 

This script is designed to be used is a regular script. In a local script it will weld, but it will not attempt to handle ancestory changes. 
]]

--[[ DOCUMENTATION
- Will work in tools. If ran more than once it will not create more than one weld.  This is especially useful for tools that are dropped and then picked up again.
- Will work in PBS servers
- Will work as long as it starts out with the part anchored
- Stores the relative CFrame as a CFrame value
- Takes careful measure to reduce lag by not having a joint set off or affected by the parts offset from origin
- Utilizes a recursive algorith to find all parts in the model
- Will reweld on script reparent if the script is initially parented to a tool.
- Welds as fast as possible
]]

-- qPerfectionWeld.lua
-- Created 10/6/2014
-- Author: Quenty
-- Version 1.0.3

-- Updated 10/14/2014 - Updated to 1.0.1
--- Bug fix with existing ROBLOX welds ? Repro by asimo3089

-- Updated 10/14/2014 - Updated to 1.0.2
--- Fixed bug fix. 

-- Updated 10/14/2014 - Updated to 1.0.3
--- Now handles joints semi-acceptably. May be rather hacky with some joints. :/

local NEVER_BREAK_JOINTS = false -- If you set this to true it will never break joints (this can create some welding issues, but can save stuff like hinges).


local function CallOnChildren(Instance, FunctionToCall)
	-- Calls a function on each of the children of a certain object, using recursion.  

	FunctionToCall(Instance)

	for _, Child in next, Instance:GetChildren() do
		CallOnChildren(Child, FunctionToCall)
	end
end

local function GetNearestParent(Instance, ClassName)
	-- Returns the nearest parent of a certain class, or returns nil

	local Ancestor = Instance
	repeat
		Ancestor = Ancestor.Parent
		if Ancestor == nil then
			return nil
		end
	until Ancestor:IsA(ClassName)

	return Ancestor
end

local function GetBricks(StartInstance)
	local List = {}

	-- if StartInstance:IsA("BasePart") then
	-- 	List[#List+1] = StartInstance
	-- end

	CallOnChildren(StartInstance, function(Item)
		if Item:IsA("BasePart") then
			List[#List+1] = Item;
		end
	end)

	return List
end

local function Modify(Instance, Values)
	-- Modifies an Instance by using a table.  

	assert(type(Values) == "table", "Values is not a table");

	for Index, Value in next, Values do
		if type(Index) == "number" then
			Value.Parent = Instance
		else
			Instance[Index] = Value
		end
	end
	return Instance
end

local function Make(ClassType, Properties)
	-- Using a syntax hack to create a nice way to Make new items.  

	return Modify(Instance.new(ClassType), Properties)
end

local Surfaces = {"TopSurface", "BottomSurface", "LeftSurface", "RightSurface", "FrontSurface", "BackSurface"}
local HingSurfaces = {"Hinge", "Motor", "SteppingMotor"}

local function HasWheelJoint(Part)
	for _, SurfaceName in pairs(Surfaces) do
		for _, HingSurfaceName in pairs(HingSurfaces) do
			if Part[SurfaceName].Name == HingSurfaceName then
				return true
			end
		end
	end
	
	return false
end

local function ShouldBreakJoints(Part)
	--- We do not want to break joints of wheels/hinges. This takes the utmost care to not do this. There are
	--  definitely some edge cases. 

	if NEVER_BREAK_JOINTS then
		return false
	end
	
	if HasWheelJoint(Part) then
		return false
	end
	
	local Connected = Part:GetConnectedParts()
	
	if #Connected == 1 then
		return false
	end
	
	for _, Item in pairs(Connected) do
		if HasWheelJoint(Item) then
			return false
		elseif not Item:IsDescendantOf(script.Parent) then
			return false
		end
	end
	
	return true
end

local function WeldTogether(Part0, Part1, JointType, WeldParent)
	--- Weld's 2 parts together
	-- @param Part0 The first part
	-- @param Part1 The second part (Dependent part most of the time).
	-- @param [JointType] The type of joint. Defaults to weld.
	-- @param [WeldParent] Parent of the weld, Defaults to Part0 (so GC is better).
	-- @return The weld created.

	JointType = JointType or "Weld"
	local RelativeValue = Part1:FindFirstChild("qRelativeCFrameWeldValue")
	
	local NewWeld = Part1:FindFirstChild("qCFrameWeldThingy") or Instance.new(JointType)
	Modify(NewWeld, {
		Name = "qCFrameWeldThingy";
		Part0  = Part0;
		Part1  = Part1;
		C0     = CFrame.new();--Part0.CFrame:inverse();
		C1     = RelativeValue and RelativeValue.Value or Part1.CFrame:toObjectSpace(Part0.CFrame); --Part1.CFrame:inverse() * Part0.CFrame;-- Part1.CFrame:inverse();
		Parent = Part1;
	})

	if not RelativeValue then
		RelativeValue = Make("CFrameValue", {
			Parent     = Part1;
			Name       = "qRelativeCFrameWeldValue";
			Archivable = true;
			Value      = NewWeld.C1;
		})
	end

	return NewWeld
end

local function WeldParts(Parts, MainPart, JointType, DoNotUnanchor)
	-- @param Parts The Parts to weld. Should be anchored to prevent really horrible results.
	-- @param MainPart The part to weld the model to (can be in the model).
	-- @param [JointType] The type of joint. Defaults to weld. 
	-- @parm DoNotUnanchor Boolean, if true, will not unachor the model after cmopletion.
	
	for _, Part in pairs(Parts) do
		if ShouldBreakJoints(Part) then
			Part:BreakJoints()
		end
	end
	
	for _, Part in pairs(Parts) do
		if Part ~= MainPart then
			WeldTogether(MainPart, Part, JointType, MainPart)
		end
	end

	if not DoNotUnanchor then
		for _, Part in pairs(Parts) do
			Part.Anchored = false
		end
		MainPart.Anchored = false
	end
end

local function PerfectionWeld()	
	local Tool = GetNearestParent(script, "Tool")

	local Parts = GetBricks(script.Parent)
	local PrimaryPart = Tool and Tool:FindFirstChild("Handle") and Tool.Handle:IsA("BasePart") and Tool.Handle or script.Parent:IsA("Model") and script.Parent.PrimaryPart or Parts[1]

	if PrimaryPart then
		WeldParts(Parts, PrimaryPart, "Weld", false)
	else
		warn("qWeld - Unable to weld part")
	end
	
	return Tool
end

local Tool = PerfectionWeld()


if Tool and script.ClassName == "Script" then
	--- Don't bother with local scripts

	script.Parent.AncestryChanged:connect(function()
		PerfectionWeld()
	end)
end

-- Created by Quenty (@Quenty, follow me on twitter).

end,
function(script,require)
-- Created by Quenty (@Quenty, follow me on twitter).
-- Should work with only ONE copy, seamlessly with weapons, trains, et cetera.
-- Parts should be ANCHORED before use. It will, however, store relatives values and so when tools are reparented, it'll fix them.

--[[ INSTRUCTIONS
- Place in the model
- Make sure model is anchored
- That's it. It will weld the model and all children. 

THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 

This script is designed to be used is a regular script. In a local script it will weld, but it will not attempt to handle ancestory changes. 
]]

--[[ DOCUMENTATION
- Will work in tools. If ran more than once it will not create more than one weld.  This is especially useful for tools that are dropped and then picked up again.
- Will work in PBS servers
- Will work as long as it starts out with the part anchored
- Stores the relative CFrame as a CFrame value
- Takes careful measure to reduce lag by not having a joint set off or affected by the parts offset from origin
- Utilizes a recursive algorith to find all parts in the model
- Will reweld on script reparent if the script is initially parented to a tool.
- Welds as fast as possible
]]

-- qPerfectionWeld.lua
-- Created 10/6/2014
-- Author: Quenty
-- Version 1.0.3

-- Updated 10/14/2014 - Updated to 1.0.1
--- Bug fix with existing ROBLOX welds ? Repro by asimo3089

-- Updated 10/14/2014 - Updated to 1.0.2
--- Fixed bug fix. 

-- Updated 10/14/2014 - Updated to 1.0.3
--- Now handles joints semi-acceptably. May be rather hacky with some joints. :/

local NEVER_BREAK_JOINTS = false -- If you set this to true it will never break joints (this can create some welding issues, but can save stuff like hinges).


local function CallOnChildren(Instance, FunctionToCall)
	-- Calls a function on each of the children of a certain object, using recursion.  

	FunctionToCall(Instance)

	for _, Child in next, Instance:GetChildren() do
		CallOnChildren(Child, FunctionToCall)
	end
end

local function GetNearestParent(Instance, ClassName)
	-- Returns the nearest parent of a certain class, or returns nil

	local Ancestor = Instance
	repeat
		Ancestor = Ancestor.Parent
		if Ancestor == nil then
			return nil
		end
	until Ancestor:IsA(ClassName)

	return Ancestor
end

local function GetBricks(StartInstance)
	local List = {}

	-- if StartInstance:IsA("BasePart") then
	-- 	List[#List+1] = StartInstance
	-- end

	CallOnChildren(StartInstance, function(Item)
		if Item:IsA("BasePart") then
			List[#List+1] = Item;
		end
	end)

	return List
end

local function Modify(Instance, Values)
	-- Modifies an Instance by using a table.  

	assert(type(Values) == "table", "Values is not a table");

	for Index, Value in next, Values do
		if type(Index) == "number" then
			Value.Parent = Instance
		else
			Instance[Index] = Value
		end
	end
	return Instance
end

local function Make(ClassType, Properties)
	-- Using a syntax hack to create a nice way to Make new items.  

	return Modify(Instance.new(ClassType), Properties)
end

local Surfaces = {"TopSurface", "BottomSurface", "LeftSurface", "RightSurface", "FrontSurface", "BackSurface"}
local HingSurfaces = {"Hinge", "Motor", "SteppingMotor"}

local function HasWheelJoint(Part)
	for _, SurfaceName in pairs(Surfaces) do
		for _, HingSurfaceName in pairs(HingSurfaces) do
			if Part[SurfaceName].Name == HingSurfaceName then
				return true
			end
		end
	end
	
	return false
end

local function ShouldBreakJoints(Part)
	--- We do not want to break joints of wheels/hinges. This takes the utmost care to not do this. There are
	--  definitely some edge cases. 

	if NEVER_BREAK_JOINTS then
		return false
	end
	
	if HasWheelJoint(Part) then
		return false
	end
	
	local Connected = Part:GetConnectedParts()
	
	if #Connected == 1 then
		return false
	end
	
	for _, Item in pairs(Connected) do
		if HasWheelJoint(Item) then
			return false
		elseif not Item:IsDescendantOf(script.Parent) then
			return false
		end
	end
	
	return true
end

local function WeldTogether(Part0, Part1, JointType, WeldParent)
	--- Weld's 2 parts together
	-- @param Part0 The first part
	-- @param Part1 The second part (Dependent part most of the time).
	-- @param [JointType] The type of joint. Defaults to weld.
	-- @param [WeldParent] Parent of the weld, Defaults to Part0 (so GC is better).
	-- @return The weld created.

	JointType = JointType or "Weld"
	local RelativeValue = Part1:FindFirstChild("qRelativeCFrameWeldValue")
	
	local NewWeld = Part1:FindFirstChild("qCFrameWeldThingy") or Instance.new(JointType)
	Modify(NewWeld, {
		Name = "qCFrameWeldThingy";
		Part0  = Part0;
		Part1  = Part1;
		C0     = CFrame.new();--Part0.CFrame:inverse();
		C1     = RelativeValue and RelativeValue.Value or Part1.CFrame:toObjectSpace(Part0.CFrame); --Part1.CFrame:inverse() * Part0.CFrame;-- Part1.CFrame:inverse();
		Parent = Part1;
	})

	if not RelativeValue then
		RelativeValue = Make("CFrameValue", {
			Parent     = Part1;
			Name       = "qRelativeCFrameWeldValue";
			Archivable = true;
			Value      = NewWeld.C1;
		})
	end

	return NewWeld
end

local function WeldParts(Parts, MainPart, JointType, DoNotUnanchor)
	-- @param Parts The Parts to weld. Should be anchored to prevent really horrible results.
	-- @param MainPart The part to weld the model to (can be in the model).
	-- @param [JointType] The type of joint. Defaults to weld. 
	-- @parm DoNotUnanchor Boolean, if true, will not unachor the model after cmopletion.
	
	for _, Part in pairs(Parts) do
		if ShouldBreakJoints(Part) then
			Part:BreakJoints()
		end
	end
	
	for _, Part in pairs(Parts) do
		if Part ~= MainPart then
			WeldTogether(MainPart, Part, JointType, MainPart)
		end
	end

	if not DoNotUnanchor then
		for _, Part in pairs(Parts) do
			Part.Anchored = false
		end
		MainPart.Anchored = false
	end
end

local function PerfectionWeld()	
	local Tool = GetNearestParent(script, "Tool")

	local Parts = GetBricks(script.Parent)
	local PrimaryPart = Tool and Tool:FindFirstChild("Handle") and Tool.Handle:IsA("BasePart") and Tool.Handle or script.Parent:IsA("Model") and script.Parent.PrimaryPart or Parts[1]

	if PrimaryPart then
		WeldParts(Parts, PrimaryPart, "Weld", false)
	else
		warn("qWeld - Unable to weld part")
	end
	
	return Tool
end

local Tool = PerfectionWeld()


if Tool and script.ClassName == "Script" then
	--- Don't bother with local scripts

	script.Parent.AncestryChanged:connect(function()
		PerfectionWeld()
	end)
end

-- Created by Quenty (@Quenty, follow me on twitter).

end,
function(script,require)
-- Created by Quenty (@Quenty, follow me on twitter).
-- Should work with only ONE copy, seamlessly with weapons, trains, et cetera.
-- Parts should be ANCHORED before use. It will, however, store relatives values and so when tools are reparented, it'll fix them.

--[[ INSTRUCTIONS
- Place in the model
- Make sure model is anchored
- That's it. It will weld the model and all children. 

THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 

This script is designed to be used is a regular script. In a local script it will weld, but it will not attempt to handle ancestory changes. 
]]

--[[ DOCUMENTATION
- Will work in tools. If ran more than once it will not create more than one weld.  This is especially useful for tools that are dropped and then picked up again.
- Will work in PBS servers
- Will work as long as it starts out with the part anchored
- Stores the relative CFrame as a CFrame value
- Takes careful measure to reduce lag by not having a joint set off or affected by the parts offset from origin
- Utilizes a recursive algorith to find all parts in the model
- Will reweld on script reparent if the script is initially parented to a tool.
- Welds as fast as possible
]]

-- qPerfectionWeld.lua
-- Created 10/6/2014
-- Author: Quenty
-- Version 1.0.3

-- Updated 10/14/2014 - Updated to 1.0.1
--- Bug fix with existing ROBLOX welds ? Repro by asimo3089

-- Updated 10/14/2014 - Updated to 1.0.2
--- Fixed bug fix. 

-- Updated 10/14/2014 - Updated to 1.0.3
--- Now handles joints semi-acceptably. May be rather hacky with some joints. :/

local NEVER_BREAK_JOINTS = false -- If you set this to true it will never break joints (this can create some welding issues, but can save stuff like hinges).


local function CallOnChildren(Instance, FunctionToCall)
	-- Calls a function on each of the children of a certain object, using recursion.  

	FunctionToCall(Instance)

	for _, Child in next, Instance:GetChildren() do
		CallOnChildren(Child, FunctionToCall)
	end
end

local function GetNearestParent(Instance, ClassName)
	-- Returns the nearest parent of a certain class, or returns nil

	local Ancestor = Instance
	repeat
		Ancestor = Ancestor.Parent
		if Ancestor == nil then
			return nil
		end
	until Ancestor:IsA(ClassName)

	return Ancestor
end

local function GetBricks(StartInstance)
	local List = {}

	-- if StartInstance:IsA("BasePart") then
	-- 	List[#List+1] = StartInstance
	-- end

	CallOnChildren(StartInstance, function(Item)
		if Item:IsA("BasePart") then
			List[#List+1] = Item;
		end
	end)

	return List
end

local function Modify(Instance, Values)
	-- Modifies an Instance by using a table.  

	assert(type(Values) == "table", "Values is not a table");

	for Index, Value in next, Values do
		if type(Index) == "number" then
			Value.Parent = Instance
		else
			Instance[Index] = Value
		end
	end
	return Instance
end

local function Make(ClassType, Properties)
	-- Using a syntax hack to create a nice way to Make new items.  

	return Modify(Instance.new(ClassType), Properties)
end

local Surfaces = {"TopSurface", "BottomSurface", "LeftSurface", "RightSurface", "FrontSurface", "BackSurface"}
local HingSurfaces = {"Hinge", "Motor", "SteppingMotor"}

local function HasWheelJoint(Part)
	for _, SurfaceName in pairs(Surfaces) do
		for _, HingSurfaceName in pairs(HingSurfaces) do
			if Part[SurfaceName].Name == HingSurfaceName then
				return true
			end
		end
	end
	
	return false
end

local function ShouldBreakJoints(Part)
	--- We do not want to break joints of wheels/hinges. This takes the utmost care to not do this. There are
	--  definitely some edge cases. 

	if NEVER_BREAK_JOINTS then
		return false
	end
	
	if HasWheelJoint(Part) then
		return false
	end
	
	local Connected = Part:GetConnectedParts()
	
	if #Connected == 1 then
		return false
	end
	
	for _, Item in pairs(Connected) do
		if HasWheelJoint(Item) then
			return false
		elseif not Item:IsDescendantOf(script.Parent) then
			return false
		end
	end
	
	return true
end

local function WeldTogether(Part0, Part1, JointType, WeldParent)
	--- Weld's 2 parts together
	-- @param Part0 The first part
	-- @param Part1 The second part (Dependent part most of the time).
	-- @param [JointType] The type of joint. Defaults to weld.
	-- @param [WeldParent] Parent of the weld, Defaults to Part0 (so GC is better).
	-- @return The weld created.

	JointType = JointType or "Weld"
	local RelativeValue = Part1:FindFirstChild("qRelativeCFrameWeldValue")
	
	local NewWeld = Part1:FindFirstChild("qCFrameWeldThingy") or Instance.new(JointType)
	Modify(NewWeld, {
		Name = "qCFrameWeldThingy";
		Part0  = Part0;
		Part1  = Part1;
		C0     = CFrame.new();--Part0.CFrame:inverse();
		C1     = RelativeValue and RelativeValue.Value or Part1.CFrame:toObjectSpace(Part0.CFrame); --Part1.CFrame:inverse() * Part0.CFrame;-- Part1.CFrame:inverse();
		Parent = Part1;
	})

	if not RelativeValue then
		RelativeValue = Make("CFrameValue", {
			Parent     = Part1;
			Name       = "qRelativeCFrameWeldValue";
			Archivable = true;
			Value      = NewWeld.C1;
		})
	end

	return NewWeld
end

local function WeldParts(Parts, MainPart, JointType, DoNotUnanchor)
	-- @param Parts The Parts to weld. Should be anchored to prevent really horrible results.
	-- @param MainPart The part to weld the model to (can be in the model).
	-- @param [JointType] The type of joint. Defaults to weld. 
	-- @parm DoNotUnanchor Boolean, if true, will not unachor the model after cmopletion.
	
	for _, Part in pairs(Parts) do
		if ShouldBreakJoints(Part) then
			Part:BreakJoints()
		end
	end
	
	for _, Part in pairs(Parts) do
		if Part ~= MainPart then
			WeldTogether(MainPart, Part, JointType, MainPart)
		end
	end

	if not DoNotUnanchor then
		for _, Part in pairs(Parts) do
			Part.Anchored = false
		end
		MainPart.Anchored = false
	end
end

local function PerfectionWeld()	
	local Tool = GetNearestParent(script, "Tool")

	local Parts = GetBricks(script.Parent)
	local PrimaryPart = Tool and Tool:FindFirstChild("Handle") and Tool.Handle:IsA("BasePart") and Tool.Handle or script.Parent:IsA("Model") and script.Parent.PrimaryPart or Parts[1]

	if PrimaryPart then
		WeldParts(Parts, PrimaryPart, "Weld", false)
	else
		warn("qWeld - Unable to weld part")
	end
	
	return Tool
end

local Tool = PerfectionWeld()


if Tool and script.ClassName == "Script" then
	--- Don't bother with local scripts

	script.Parent.AncestryChanged:connect(function()
		PerfectionWeld()
	end)
end

-- Created by Quenty (@Quenty, follow me on twitter).

end,
function(script,require)
local event = script.Parent.Parent.Parent.Events.Gear

local gear = "DOWN"

spawn(function()
	for i,v in pairs(script.Parent.Parent:GetChildren()) do
		if v.Name == "GearPivot" then
			if v:FindFirstChildOfClass("Motor6D") then
				local mot = v:FindFirstChildOfClass("Motor6D")
				mot.DesiredAngle = mot:FindFirstChild("Ang").Value
			end
		end
	end
	for i,v in pairs(script.Parent.Parent:GetChildren()) do
		if v.Name == "GearDPivot" then
			if v:FindFirstChildOfClass("Motor6D") then
				local mot = v:FindFirstChildOfClass("Motor6D")
				mot.DesiredAngle = mot:FindFirstChild("Ang").Value
			end
		end
	end
end)


event.OnServerEvent:Connect(function()
	if gear == "DOWN" then

		gear = "UP"
		local move = coroutine.create(function()
			for i,v in pairs(script.Parent.Parent:GetChildren()) do
				if v.Name == "GearPivot" then
					if v:FindFirstChildOfClass("Motor6D") then
						local mot = v:FindFirstChildOfClass("Motor6D")
						mot.DesiredAngle = 0
					end
				end
			end
			wait(1)
			for i,v in pairs(script.Parent.Parent:GetChildren()) do
				if v.Name == "GearDPivot" then
					if v:FindFirstChildOfClass("Motor6D") then
						local mot = v:FindFirstChildOfClass("Motor6D")
						mot.DesiredAngle = 0
					end
				end
			end
		end)
		
		coroutine.resume(move)
	elseif gear == "UP" then

		gear = "DOWN"
		local move = coroutine.create(function()
			for i,v in pairs(script.Parent.Parent:GetChildren()) do
				if v.Name == "GearDPivot" then
					if v:FindFirstChildOfClass("Motor6D") then
						local mot = v:FindFirstChildOfClass("Motor6D")
						mot.DesiredAngle = mot:FindFirstChild("Ang").Value
					end
				end
			end
			wait(1)
			for i,v in pairs(script.Parent.Parent:GetChildren()) do
				if v.Name == "GearPivot" then
					if v:FindFirstChildOfClass("Motor6D") then
						local mot = v:FindFirstChildOfClass("Motor6D")
						mot.DesiredAngle = mot:FindFirstChild("Ang").Value
					end
				end
			end
		end)

		coroutine.resume(move)
	end
	
end)
end
}
local ScriptIndex = 0
local Scripts,ModuleScripts,ModuleCache = {},{},{}
local _require = require
function require(obj,...)
	local index = ModuleScripts[obj]
	if not index then
		local a,b = pcall(_require,obj,...)
		return not a and error(b,2) or b
	end
	
	local res = ModuleCache[index]
	if res then return res end
	res = ScriptFunctions[index](obj,require)
	if res==nil then error("Module code did not return exactly one value",2) end
	ModuleCache[index] = res
	return res
end
local function Script(obj,ismodule)
	ScriptIndex = ScriptIndex + 1
	local t = ismodule and ModuleScripts or Scripts
	t[obj] = ScriptIndex
end

function RunScripts()
	for script,index in pairs(Scripts) do
		coroutine.wrap(ScriptFunctions[index])(script,require)
	end
end


local function DecodeUnion(Values,Flags,Parse,data)
	local m = Instance.new("Folder")
	m.Name = "UnionCache ["..tostring(math.random(1,9999)).."]"
	m.Archivable = false
	m.Parent = game:GetService("ServerStorage")
	local Union,Subtract = {},{}
	if not data then
		data = Parse('B')
	end
	local ByteLength = (data % 4) + 1
	local Length = Parse('I'..ByteLength)
	local ValueFMT = ('I'..Flags[1])
	for i = 1,Length do
		local data = Parse('B')
		local part
		local isNegate = bit32.band(data,0b10000000) > 0
		local isUnion =  bit32.band(data,0b01000000) > 0
		if isUnion then
			part = DecodeUnion(Values,Flags,Parse,data)
		else
			local isMesh = data % 2 == 1
			local ClassName = Values[Parse(ValueFMT)]
			part = Instance.new(ClassName)
			part.Size = Values[Parse(ValueFMT)]
			part.Position = Values[Parse(ValueFMT)]
			part.Orientation = Values[Parse(ValueFMT)]
			if isMesh then
				local mesh = Instance.new("SpecialMesh")
				mesh.MeshType = Values[Parse(ValueFMT)]
				mesh.Scale = Values[Parse(ValueFMT)]
				mesh.Offset = Values[Parse(ValueFMT)]
				mesh.Parent = part
			end
		end
		part.Parent = m
		table.insert(isNegate and Subtract or Union,part)
	end
	local first = table.remove(Union,1)
	if #Union>0 then
		first = first:UnionAsync(Union)
	end
	if #Subtract>0 then
		first = first:SubtractAsync(Subtract)
	end
	m:Destroy()
	return first
end

local function Decode(str)
	local StringLength = #str
	
	-- Base64 decoding
	do
		local decoder = {}
		for b64code, char in pairs(('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='):split('')) do
			decoder[char:byte()] = b64code-1
		end
		local n = StringLength
		local t,k = table.create(math.floor(n/4)+1),1
		local padding = str:sub(-2) == '==' and 2 or str:sub(-1) == '=' and 1 or 0
		for i = 1, padding > 0 and n-4 or n, 4 do
			local a, b, c, d = str:byte(i,i+3)
			local v = decoder[a]*0x40000 + decoder[b]*0x1000 + decoder[c]*0x40 + decoder[d]
			t[k] = string.char(bit32.extract(v,16,8),bit32.extract(v,8,8),bit32.extract(v,0,8))
			k = k + 1
		end
		if padding == 1 then
			local a, b, c = str:byte(n-3,n-1)
			local v = decoder[a]*0x40000 + decoder[b]*0x1000 + decoder[c]*0x40
			t[k] = string.char(bit32.extract(v,16,8),bit32.extract(v,8,8))
		elseif padding == 2 then
			local a, b = str:byte(n-3,n-2)
			local v = decoder[a]*0x40000 + decoder[b]*0x1000
			t[k] = string.char(bit32.extract(v,16,8))
		end
		str = table.concat(t)
	end
	
	local Position = 1
	local function Parse(fmt)
		local Values = {string.unpack(fmt,str,Position)}
		Position = table.remove(Values)
		return table.unpack(Values)
	end
	
	local Settings = Parse('B')
	local Flags = Parse('B')
	Flags = {
		--[[ValueIndexByteLength]] bit32.extract(Flags,6,2)+1,
		--[[InstanceIndexByteLength]] bit32.extract(Flags,4,2)+1,
		--[[ConnectionsIndexByteLength]] bit32.extract(Flags,2,2)+1,
		--[[MaxPropertiesLengthByteLength]] bit32.extract(Flags,0,2)+1,
		--[[Use Double instead of Float]] bit32.band(Settings,0b1) > 0
	}
	
	local ValueFMT = ('I'..Flags[1])
	local InstanceFMT = ('I'..Flags[2])
	local ConnectionFMT = ('I'..Flags[3])
	local PropertyLengthFMT = ('I'..Flags[4])
	
	local ValuesLength = Parse(ValueFMT)
	local Values = table.create(ValuesLength)
	local CFrameIndexes = {}
	
	local ValueDecoders = {
		--!!Start
		[1] = function(Modifier)
			return Parse('s'..Modifier)
		end,
		--!!Split
		[2] = function(Modifier)
			return Modifier ~= 0
		end,
		--!!Split
		[3] = function()
			return Parse('d')
		end,
		--!!Split
		[4] = function(_,Index)
			table.insert(CFrameIndexes,{Index,Parse(('I'..Flags[1]):rep(3))})
		end,
		--!!Split
		[5] = {CFrame.new,Flags[5] and 'dddddddddddd' or 'ffffffffffff'},
		--!!Split
		[6] = {Color3.fromRGB,'BBB'},
		--!!Split
		[7] = {BrickColor.new,'I2'},
		--!!Split
		[8] = function(Modifier)
			local len = Parse('I'..Modifier)
			local kpts = table.create(len)
			for i = 1,len do
				kpts[i] = ColorSequenceKeypoint.new(Parse('f'),Color3.fromRGB(Parse('BBB')))
			end
			return ColorSequence.new(kpts)
		end,
		--!!Split
		[9] = function(Modifier)
			local len = Parse('I'..Modifier)
			local kpts = table.create(len)
			for i = 1,len do
				kpts[i] = NumberSequenceKeypoint.new(Parse(Flags[5] and 'ddd' or 'fff'))
			end
			return NumberSequence.new(kpts)
		end,
		--!!Split
		[10] = {Vector3.new,Flags[5] and 'ddd' or 'fff'},
		--!!Split
		[11] = {Vector2.new,Flags[5] and 'dd' or 'ff'},
		--!!Split
		[12] = {UDim2.new,Flags[5] and 'di2di2' or 'fi2fi2'},
		--!!Split
		[13] = {Rect.new,Flags[5] and 'dddd' or 'ffff'},
		--!!Split
		[14] = function()
			local flags = Parse('B')
			local ids = {"Top","Bottom","Left","Right","Front","Back"}
			local t = {}
			for i = 0,5 do
				if bit32.extract(flags,i,1)==1 then
					table.insert(t,Enum.NormalId[ids[i+1]])
				end
			end
			return Axes.new(unpack(t))
		end,
		--!!Split
		[15] = function()
			local flags = Parse('B')
			local ids = {"Top","Bottom","Left","Right","Front","Back"}
			local t = {}
			for i = 0,5 do
				if bit32.extract(flags,i,1)==1 then
					table.insert(t,Enum.NormalId[ids[i+1]])
				end
			end
			return Faces.new(unpack(t))
		end,
		--!!Split
		[16] = {PhysicalProperties.new,Flags[5] and 'ddddd' or 'fffff'},
		--!!Split
		[17] = {NumberRange.new,Flags[5] and 'dd' or 'ff'},
		--!!Split
		[18] = {UDim.new,Flags[5] and 'di2' or 'fi2'},
		--!!Split
		[19] = function()
			return Ray.new(Vector3.new(Parse(Flags[5] and 'ddd' or 'fff')),Vector3.new(Parse(Flags[5] and 'ddd' or 'fff')))
		end
		--!!End
	}
	
	for i = 1,ValuesLength do
		local TypeAndModifier = Parse('B')
		local Type = bit32.band(TypeAndModifier,0b11111)
		local Modifier = (TypeAndModifier - Type) / 0b100000
		local Decoder = ValueDecoders[Type]
		if type(Decoder)=='function' then
			Values[i] = Decoder(Modifier,i)
		else
			Values[i] = Decoder[1](Parse(Decoder[2]))
		end
	end
	
	for i,t in pairs(CFrameIndexes) do
		Values[t[1]] = CFrame.fromMatrix(Values[t[2]],Values[t[3]],Values[t[4]])
	end
	
	local InstancesLength = Parse(InstanceFMT)
	local Instances = {}
	local NoParent = {}
	
	for i = 1,InstancesLength do
		local ClassName = Values[Parse(ValueFMT)]
		local obj
		local MeshPartMesh,MeshPartScale
		if ClassName == "UnionOperation" then
			obj = DecodeUnion(Values,Flags,Parse)
			obj.UsePartColor = true
		elseif ClassName:find("Script") then
			obj = Instance.new("Folder")
			Script(obj,ClassName=='ModuleScript')
		elseif ClassName == "MeshPart" then
			obj = Instance.new("Part")
			MeshPartMesh = Instance.new("SpecialMesh")
			MeshPartMesh.MeshType = Enum.MeshType.FileMesh
			MeshPartMesh.Parent = obj
		else
			obj = Instance.new(ClassName)
		end
		local Parent = Instances[Parse(InstanceFMT)]
		local PropertiesLength = Parse(PropertyLengthFMT)
		local AttributesLength = Parse(PropertyLengthFMT)
		Instances[i] = obj
		for i = 1,PropertiesLength do
			local Prop,Value = Values[Parse(ValueFMT)],Values[Parse(ValueFMT)]
			
			-- ok this looks awful
			if MeshPartMesh then
				if Prop == "MeshId" then
					MeshPartMesh.MeshId = Value
					continue
				elseif Prop == "TextureID" then
					MeshPartMesh.TextureId = Value
					continue
				elseif Prop == "Size" then
					if not MeshPartScale then
						MeshPartScale = Value
					else
						MeshPartMesh.Scale = Value / MeshPartScale
					end
				elseif Prop == "MeshSize" then
					if not MeshPartScale then
						MeshPartScale = Value
						MeshPartMesh.Scale = obj.Size / Value
					else
						MeshPartMesh.Scale = MeshPartScale / Value
					end
					continue
				end
			end
			
			obj[Prop] = Value
		end
		if MeshPartMesh then
			if MeshPartMesh.MeshId=='' then
				if MeshPartMesh.TextureId=='' then
					MeshPartMesh.TextureId = 'rbxasset://textures/meshPartFallback.png'
				end
				MeshPartMesh.Scale = obj.Size
			end
		end
		for i = 1,AttributesLength do
			obj:SetAttribute(Values[Parse(ValueFMT)],Values[Parse(ValueFMT)])
		end
		if not Parent then
			table.insert(NoParent,obj)
		else
			obj.Parent = Parent
		end
	end
	
	local ConnectionsLength = Parse(ConnectionFMT)
	for i = 1,ConnectionsLength do
		local a,b,c = Parse(InstanceFMT),Parse(ValueFMT),Parse(InstanceFMT)
		Instances[a][Values[b]] = Instances[c]
	end
	
	return NoParent
end


local Objects = Decode('AFAbBiEFTW9kZWwhBE5hbWUhB0JvZHlLaXQhCldvcmxkUGl2b3QEyAXJBcoFIQRCb2R5BMsFyQXKBSEITWVzaFBhcnQhFk1lc2hlcy9BMTBBX3dpbmdfci4wMDIhCEFuY2hvcmVkIiEGQ0ZyYW1lBBQAyQXKBSEITWFzc2xlc3MhCE1hdGVyaWFsAwAAAAAAgJRAIQtPcmllbnRhdGlvbgoAAAAAAAC0QgAAAAAhCFBvc2l0aW9uCl756UJcPr9AFPXGwiEIUm90YXRpb24hBFNpemUK2zrLQRZYWkCRxFdBIQZNZXNoSWQhGHJieGFzc2V0aWQ6Ly8xMTMwMjE5NjMwMyE'
..'ITWVzaFNpemUK0lQ7P11DyT1y48Y+IQlUZXh0dXJlSUQhGHJieGFzc2V0aWQ6Ly8xMTMwMjE5NjM0MSEXTWVzaGVzL0ExMEFfYm9tYl9weWxvbjUEIADJBcoFCtxs5ELgZ29AvTGlwgoFY48/STyRP7r+8kAhGHJieGFzc2V0aWQ6Ly8xMTMwMjE4MTA4MQpzKwQ9st8FPVT8Xz4hGHJieGFzc2V0aWQ6Ly8xMTMwMjE4MTEyOCEXTWVzaGVzL0ExMEFfYW5fYWxlXzQwX3IEJwDJBcoFCkjO6EIs8q9Aw//Owgoe3qtBaqpdQB1b3EAhGHJieGFzc2V0aWQ6Ly8xMTMwMj'
..'E3Mzg0MworbB4/LFPMPRoeSz4hGHJieGFzc2V0aWQ6Ly8xMTMwMjE3NDAwMyETTWVzaGVzL0ExMEFfZmxhcDNfcgQuAMkFygUKhtDqQgz9r0BtAcTCChWN4UB29Ww/VZ7/PSEYcmJ4YXNzZXRpZDovLzExMzAyMTg2MTIyCgjoTz70a9o8IJ9rOyEYcmJ4YXNzZXRpZDovLzExMzAyMTg2NDE1IRRNZXNoZXMvQTEwQV90YWlsLjAwMgQ1AMkFygUKrMgIQxrTDUGCM6nCChVWpEFWKgVB6VK3QCEYcmJ4YXNzZXRpZDovLzExMzAyMTk0MzEwCvd6Fz/vfnU+iPsoPiEYc'
..'mJ4YXNzZXRpZDovLzExMzAyMTk0MzUzIRRNZXNoZXMvQTEwQV9ibGlzdGVyNAQ8AMkFygUKvIzPQkqtGkGGM6nCCtL17j6WAis/e3ATPyEYcmJ4YXNzZXRpZDovLzExMzAyMTEwNTE5CjlEXDzQoZ08wOeHPCEYcmJ4YXNzZXRpZDovLzExMzAyMTEwNjcwIRRNZXNoZXMvQTEwQV90YWlsLjAwNARDAMkFygUK/TAJQzASC0FmrJfCCkVZWUAUsydBww61QCEYcmJ4YXNzZXRpZDovLzExMzAyMTMyNTY2CnxYyD2blJo+xOQmPiEYcmJ4YXNzZXRpZDovLzExMzAyMTMy'
..'NzQ4IRRNZXNoZXMvQTEwQV9ibGlzdGVyNwRKAMkFygUKxsnBQn5DuEC0AKXCCqBOjT5/rMk/L5s4PyEYcmJ4YXNzZXRpZDovLzExMzAyMTM0NjU0CrRAAjyh5Tk9ICqqPCEYcmJ4YXNzZXRpZDovLzExMzAyMTM0OTQzIRdNZXNoZXMvQTEwQV9ib21iX3B5bG9uOQRRAMkFygUK9GTjQiAsh0AVgsLCCgpjjz/mRtE/m57OQCEYcmJ4YXNzZXRpZDovLzExMzAyMTEyNzU5CngrBD3E50A9sHQ+PiEYcmJ4YXNzZXRpZDovLzExMzAyMTEyODQ3IRNNZXNoZXMvQTEwQV9'
..'mbGFwM19sBFgAyQXKBQqE0OpCzvSvQLhljsIKRY3hQBsDbT9unP89IRhyYnhhc3NldGlkOi8vMTEzMDIxODU3NzUKNOhPPoh42jxgnWs7IRhyYnhhc3NldGlkOi8vMTEzMDIxODYwMTUhFk1lc2hlcy9BMTBBX3dpbmdfci4wMDEEXwDJBcoFCri+50J8RJJAKru9wgpoY7FAlNleQHHLIEEhGHJieGFzc2V0aWQ6Ly8xMTMwMjEyODM5MgrlgiM+n2rNPUA3lD4hGHJieGFzc2V0aWQ6Ly8xMTMwMjEyODYxNCEUTWVzaGVzL0ExMEFfZnVzZS4xODcEZgDJBcoFCgZjxE'
..'JQAQ9BgjOpwgr9kotAs++FQLfsREEhGHJieGFzc2V0aWQ6Ly8xMTMwMjEzMDcwOArGpwA+yer2PfWEtT4hGHJieGFzc2V0aWQ6Ly8xMTMwMjEzMDg5OCEWTWVzaGVzL0ExMEFfYWlsZXJvbjFfbARtAMkFygUKaGvoQiwXt0BW84DCCjtneT7YuJ0+PleJPyEYcmJ4YXNzZXRpZDovLzExMzAyMTA0NzAxCoDk5TswYhE8gjH9PCEYcmJ4YXNzZXRpZDovLzExMzAyMTA0OTg1IRNNZXNoZXMvQTEwQV9nZWFyX3IzBHQAyQXKBQooI+RCsHBfQMqkusIKJhzHPiNOJz+gM'
..'eY/IRhyYnhhc3NldGlkOi8vMTEzMDIxOTIxMTcKoIg3PJA3mjyYL1Q9IRhyYnhhc3NldGlkOi8vMTEzMDIxOTI2MzMhFE1lc2hlcy9BMTBBX2Z1c2UuMDAyBHwAyQXKBQMAAAAAAABxQApGLstC0MbSQJGtqcIKM3ClQIHSBkEPLJhBIQxUcmFuc3BhcmVuY3kDAAAAQDMz4z8hGHJieGFzc2V0aWQ6Ly8xMTMwMjExNTg2MgoCfxg+6Ix4Po1EDD8hF01lc2hlcy9BMTBBX2FuX2FsZV80MF9sBIQAyQXKBQpIzuhCLPKvQEBng8IhGHJieGFzc2V0aWQ6Ly8xMTMwMjE3'
..'MzQ2MSEYcmJ4YXNzZXRpZDovLzExMzAyMTczNjI2IRRNZXNoZXMvQTEwQV90YWlsLjAwMwSJAMkFygUK7AYLQ3BK5kCCM6nCCo+8pUFETMVAyu7sQCEYcmJ4YXNzZXRpZDovLzExMzAyMTk0NTA0CmXFGD8J3TU+zGVaPiEYcmJ4YXNzZXRpZDovLzExMzAyMTk0NTUzIRRNZXNoZXMvQTEwQV9mdXNlLjA3NwSQAMkFygUKgh26QgxdtkAgDanCCpM0kUBc54dAWPQ/QSEYcmJ4YXNzZXRpZDovLzExMzAyMTQ3MDc3CpXYBT5Oi/o9IPCwPiEYcmJ4YXNzZXRpZDovLzE'
..'xMzAyMTQ3MzExIRZNZXNoZXMvQTEwQV93aW5nX2wuMDAxBJcAyQXKBQqEo+lCtkezQESDiMIKR7DiQSpFj0BTIl1BIRhyYnhhc3NldGlkOi8vMTEzMDIxMjY4MzAKcvRQP+4PBD671cs+IRhyYnhhc3NldGlkOi8vMTEzMDIxMjcwMzEhFE1lc2hlcy9BMTBBX2Z1c2UuMTQ4BJ4AyQXKBQrIrP1Cyq4MQZt5oMIK4DnJQOqVuUCRkWJBIRhyYnhhc3NldGlkOi8vMTEzMDIxNDc5MjAK+ns5Pj4RKz4i2NA+IRhyYnhhc3NldGlkOi8vMTEzMDIxNDgxMTAhE01lc2hlcy'
..'9BMTBBX2dlYXJfbDgEpQDJBcoFCgJB50LAYnFAPMKXwgoTjsM+0m04P4C72j8hGHJieGFzc2V0aWQ6Ly8xMTMwMjEyMDQwNArAQTQ8UACqPAGfST0hGHJieGFzc2V0aWQ6Ly8xMTMwMjEyMDU3MiETTWVzaGVzL0ExMEFfZmxhcDJfcgSsAMkFygUKYkPoQqwBp0B1M7bCCqVP8D0V/hs+cnf1PyEYcmJ4YXNzZXRpZDovLzExMzAyMTg1MzI0CgCDXTsQyo87jUNiPSEYcmJ4YXNzZXRpZDovLzExMzAyMTg1NjI0IRRNZXNoZXMvQTEwQV9ibGlzdGVyNgSzAMkFygUKo'
..'jvCQgTsukC9AKXCCsR8mD4yPsg/ag+bPyEYcmJ4YXNzZXRpZDovLzExMzAyMTM0MjUxCvCODDz8kzg9EO4OPSEYcmJ4YXNzZXRpZDovLzExMzAyMTM0NDY4IRRNZXNoZXMvQTEwQV9nZWFyX3IxMAS6AMkFygUKKHHkQpDSfEBsG7rCCtpVnT9NJzM/sDvlPyEYcmJ4YXNzZXRpZDovLzExMzAyMTQ0NTYwCvAGET1wI6U85UxTPSEYcmJ4YXNzZXRpZDovLzExMzAyMTQ0ODc2IRRNZXNoZXMvQTEwQV9nZWFyX2wxMATBAMkFygUKJnHkQpDSfECpS5jCCq9UnT8PJzM/'
..'sDvlPyEYcmJ4YXNzZXRpZDovLzExMzAyMTIxMDQyCtwFET04I6U85UxTPSEYcmJ4YXNzZXRpZDovLzExMzAyMTIxMTg0IRNNZXNoZXMvQTEwQV9ydWRkZXIwBMgAyQXKBQqoLgxDsIERQS4ilcIKKjNBP30/F0Gim3xAIRhyYnhhc3NldGlkOi8vMTEzMDIxMjQ5MTkKABayPHxqiz642Og9IRhyYnhhc3NldGlkOi8vMTEzMDIxMjUxOTMhF01lc2hlcy9BMTBBX2JvbWJfcHlsb240BM8AyQXKBQq6ZONC6Hx7QGq0ncIKTkSPPzsTwz/Hl85AIRhyYnhhc3NldGlkOi8'
..'vMTEzMDIxODA4ODEKJA8EPYTQMz1lbj4+IRhyYnhhc3NldGlkOi8vMTEzMDIxODA5NDIhFk1lc2hlcy9BMTBBX3dpbmdfbC4wMDME1gDJBcoFCibn50L86+JArA9awgrvvQ8/4BJiP5RvMkAhGHJieGFzc2V0aWQ6Ly8xMTMwMjEyNzM5NwpAf4Q8W2PQPBh6pD0hGHJieGFzc2V0aWQ6Ly8xMTMwMjEyNzQzMSETTWVzaGVzL0ExMEFfZ2Vhcl9yMgTdAMkFygUKhALfQmzlhUD04LnCCkJvLz5/DSY+/706PiEYcmJ4YXNzZXRpZDovLzExMzAyMTkxNDg0CuC1oTsAEJ'
..'k7KCKsOyEYcmJ4YXNzZXRpZDovLzExMzAyMTkxOTczIRNNZXNoZXMvQTEwQV9mbGFwMV9sBOQAyQXKBQpe3O1CCGejQBxEnMIKTozEQMIZNT+p8XpAIRhyYnhhc3NldGlkOi8vMTEzMDIxMTQyMzAKFyw1PujupjwSUOc9IRhyYnhhc3NldGlkOi8vMTEzMDIxMTQ1MzEhFE1lc2hlcy9BMTBBX2JsaXN0ZXIyBOsAyQXKBQoGos9CSqMgQYIzqcIK8sVwPyz2cD6e6Ic/IRhyYnhhc3NldGlkOi8vMTEzMDIxMDk3ODgKC/DdPIAc3jugjfo8IRhyYnhhc3NldGlkOi8vM'
..'TEzMDIxMTAwMzchFE1lc2hlcy9BMTBBX2Z1c2UuODkwBPIAyQXKBQpOa7ZC0niiQPxXqcIKPpp6QD4pFkC0+YpAIRhyYnhhc3NldGlkOi8vMTEzMDIxODk2MDcKfv/mPQFqij18GgA+IRhyYnhhc3NldGlkOi8vMTEzMDIxODk5MzYhE01lc2hlcy9BMTBBX2dlYXJfcjcE+QDJBcoFCi4V3kJQcolA/LC5wgrQidY+y7kuP0b8hT8hGHJieGFzc2V0aWQ6Ly8xMTMwMjE0MzM3MApQwUU8nA6hPPgB9zwhGHJieGFzc2V0aWQ6Ly8xMTMwMjE0MzY2MSETTWVzaGVzL0Ex'
..'MEFfZ2Vhcl9yNQQAAckFygUKVkXcQn7fh0Diq7nCCmQG4T7x4Fo/cmqfPyEYcmJ4YXNzZXRpZDovLzExMzAyMTQyNTUxCuBrTzyEwck83vESPSEYcmJ4YXNzZXRpZDovLzExMzAyMTQyODczIRNNZXNoZXMvQTEwQV9nZWFyX2M5BAcByQXKBQqgHLpCbn6ZQO90rMIKQIigPT/Cjz+Mt6Y+IRhyYnhhc3NldGlkOi8vMTEzMDIxNTY3NzAKUPkTOzqDBD3ArBk8IRhyYnhhc3NldGlkOi8vMTEzMDIxNTcwNTEhE01lc2hlcy9BMTBBX2dlYXJfbDYEDgHJBcoFCjA43kI'
..'4cUdAfbuYwgpxOuc+YRcbP6aZjD8hGHJieGFzc2V0aWQ6Ly8xMTMwMjExOTc0NAqwI1U8aPWOPOOZAT0hGHJieGFzc2V0aWQ6Ly8xMTMwMjExOTkxNiEUTWVzaGVzL0ExMEFfZnVzZS41NjQEFQHJBcoFCpbt7kIAXN5AgjOpwgq2SZVAt7jDQLBT50EhGHJieGFzc2V0aWQ6Ly8xMTMwMjE0ODI3Ngr2mwk+Dmk0Pvg6VT8hGHJieGFzc2V0aWQ6Ly8xMTMwMjE0ODQ1MCEUTWVzaGVzL0ExMEFfdGFpbC4wMDEEHAHJBcoFCixWCkOA08lAgjOpwgpoG2JBur9XQPhEDU'
..'EhGHJieGFzc2V0aWQ6Ly8xMTMwMjE5MzU4Mgo4a9A++97GPc43gj4hGHJieGFzc2V0aWQ6Ly8xMTMwMjE5NDEzNiESTWVzaGVzL0ExMEFfd2luZ19sBCMByQXKBQqqoedCBC/jQFyvWcIKzLkkPx3KSD/0oxlAIRhyYnhhc3NldGlkOi8vMTEzMDIxMjY3MTEK4NaXPPQUuTwKn409IRRNZXNoZXMvQTEwQV9mdXNlLjAzNQQpAckFygUKyKz9QsquDEFp7bHCIRhyYnhhc3NldGlkOi8vMTEzMDIxOTAyNDkhGHJieGFzc2V0aWQ6Ly8xMTMwMjE5MDY2NCEXTWVzaGVzL'
..'0ExMEFfYm9tYl9weWxvbjcELgHJBcoFCtxs5ELgZ29ARzWtwiEYcmJ4YXNzZXRpZDovLzExMzAyMTgxNTY3IRhyYnhhc3NldGlkOi8vMTEzMDIxODE2MDQhEk1lc2hlcy9BMTBBX3dpbmdfcgQzAckFygUKqqHnQgQv40Baj+XCIRhyYnhhc3NldGlkOi8vMTEzMDIxMjgyNTAhFE1lc2hlcy9BMTBBX2JsaXN0ZXIzBDcByQXKBQrGPMhCJosdQY8zqcIKYFVvP5+Kij8IyT0/IRhyYnhhc3NldGlkOi8vMTEzMDIxMTAxODQKTpzcPCxo/zxA8K48IRhyYnhhc3NldGlk'
..'Oi8vMTEzMDIxMTAzMjAhFE1lc2hlcy9BMTBBX2dlYXJfYzE1BD4ByQXKBQpUvr1C4HYeQQX5p8IKgBqiPSgyDj0oMg49IRhyYnhhc3NldGlkOi8vMTEzMDIxNzc0MzEKGGwVO4DrYDoAAAAAIRhyYnhhc3NldGlkOi8vMTEzMDIxNzc2NTghFE1lc2hlcy9BMTBBX2dlYXJfcjExBEUByQXKBQoA6dpCbJiGQBfeucIKQm8vPil6Rj4EVVI+IRhyYnhhc3NldGlkOi8vMTEzMDIxNTg5NTUK4LWhO1DztjvA4ME7IRhyYnhhc3NldGlkOi8vMTEzMDIxNTkyMjUhE01lc2h'
..'lcy9BMTBBX2ZsYXA0X2wETAHJBcoFCoTQ6kLacqJA+0Ocwgq1kcRAzSwAPm6c/z0hGHJieGFzc2V0aWQ6Ly8xMTMwMjE1NTAyNAoSMTU+wEtsO2CdazshGHJieGFzc2V0aWQ6Ly8xMTMwMjE1NTIxNSEUTWVzaGVzL0ExMEFfZ2Vhcl9jMTAEUwHJBcoFCgNrukJqxIhAjXWswgpKNCs9LAoRPfhc1T0hGHJieGFzc2V0aWQ6Ly8xMTMwMjE4NjQ4OQqgz506gLGFOgCsRDshGHJieGFzc2V0aWQ6Ly8xMTMwMjE4NjY5MiEUTWVzaGVzL0ExMEFfZnVzZS42MjUEWgHJBc'
..'oFCgJhw0LMYI5Ag66pwgrFUaVAAdmEQD/BE0EhGHJieGFzc2V0aWQ6Ly8xMTMwMjE0ODYyNwr2Yhg+/uj0PTMyiD4hGHJieGFzc2V0aWQ6Ly8xMTMwMjE0ODc4MyESTWVzaGVzL0ExMEFfZmxhcF9yBGEByQXKBQq6ze1CWDewQD30w8IKdxDiQL+kuD/CuXtAIRhyYnhhc3NldGlkOi8vMTEzMDIxMzg2NTYKImFQPvAyKj2FCOg9IRhyYnhhc3NldGlkOi8vMTEzMDIxMzg4MTchFE1lc2hlcy9BMTBBX3RhaWwuMDA1BGgByQXKBQr9MAlDMBILQZ66usIhGHJieGFzc'
..'2V0aWQ6Ly8xMTMwMjE3MjYyMyEYcmJ4YXNzZXRpZDovLzExMzAyMTcyODA2IRJNZXNoZXMvQTEwQV9mbGFwX2wEbQHJBcoFCrrN7UJSN7BAyHKOwgpyEOJA3aS4P7a5e0AhGHJieGFzc2V0aWQ6Ly8xMTMwMjE1NjQzNAoeYVA+DDMqPXoI6D0hGHJieGFzc2V0aWQ6Ly8xMTMwMjE1NjYwMyEWTWVzaGVzL0ExMEFfb3B0aWMxX2d1bgR0AckFygUK6J+uQrpSq0BOM6nCCigyDj0oMg49KDIOPSEYcmJ4YXNzZXRpZDovLzExMzAyMTIzMzI3CpxTyTYAggw6AKgaOiEY'
..'cmJ4YXNzZXRpZDovLzExMzAyMTIzNTk3IRZNZXNoZXMvQTEwQV93aW5nX3IuMDAzBHsByQXKBQom5+dC/OviQC9f5cIhGHJieGFzc2V0aWQ6Ly8xMTMwMjE5ODgxMiEYcmJ4YXNzZXRpZDovLzExMzAyMTk4ODY3IRRNZXNoZXMvQTEwQV9nZWFyX2MxMQSAAckFygUKqka6QmKaskAeXKzCCigyDj0BpxA/NX2JPiEYcmJ4YXNzZXRpZDovLzExMzAyMTg2Nzc4CkCqGjoYVoU8gHf9OyEYcmJ4YXNzZXRpZDovLzExMzAyMTg2OTMzIRVNZXNoZXMvQTEwQV9ibGlzdGV'
..'yMTAEhwHJBcoFCvIuyEIs4hVBoDOpwgqG+/c9Wf2XPyDY+z0hGHJieGFzc2V0aWQ6Ly8xMTMwMjEzNTg3OQpAlWQ7fhkMPYAkaDshGHJieGFzc2V0aWQ6Ly8xMTMwMjEzNjA0MSETTWVzaGVzL0ExMEFfZmxhcDRfcgSOAckFygUKhNDqQtByokA4I7bCCtKYxEDvLAA+bpz/PSEYcmJ4YXNzZXRpZDovLzExMzAyMTU1MzM1CqA3NT4ATGw7YJ1rOyEYcmJ4YXNzZXRpZDovLzExMzAyMTU1NTk1IRNNZXNoZXMvQTEwQV9mbGFwMl9sBJUByQXKBQpiQ+hCuAGnQIcznM'
..'IKNGTuPfP9Gz6Pd/U/IRhyYnhhc3NldGlkOi8vMTEzMDIxODUwOTMKAL5bO/DJjzuoQ2I9IRhyYnhhc3NldGlkOi8vMTEzMDIxODUyMjUhFU1lc2hlcy9BMTBBX3J1ZGRlcjBfMQScAckFygUKJ2ELQ7QDtUBuh5TCCqk64z3XXgc+skmhPyEYcmJ4YXNzZXRpZDovLzExMzAyMTU5MzYzCgB0UTugj3k7oKsUPSEYcmJ4YXNzZXRpZDovLzExMzAyMTU5NzE0IRZNZXNoZXMvQTEwQV9haWxlcm9uMl9yBKMByQXKBQqgyuhCBkq5QN1d0cIKHhCHPrGMpz6hG7I/IRhyY'
..'nhhc3NldGlkOi8vMTEzMDIxMDU5MzYKgP74OzhxGjy2LCQ9IRhyYnhhc3NldGlkOi8vMTEzMDIxMDYyMDEhF01lc2hlcy9BMTBBX2JvbWJfcHlsb24xBKoByQXKBQqi7+JCDkWmQF39gMIKE2OPP0Td5D8IqPFAIRhyYnhhc3NldGlkOi8vMTEzMDIxNjU0NDgKgCsEPdz1Uj1ywF4+IRhyYnhhc3NldGlkOi8vMTEzMDIxNjU1MDAhGE1lc2hlcy9BMTBBX2JvbWJfcHlsb24xMASxAckFygUKbGrjQpTalkBTEMrCCihkjz/kRtE/t6XOQCEYcmJ4YXNzZXRpZDovLzEx'
..'MzAyMTEzMDI0CoAsBD3C50A9Pns+PiEYcmJ4YXNzZXRpZDovLzExMzAyMTEzMDczIRdNZXNoZXMvQTEwQV9ib21iX3B5bG9uMwS4AckFygUK9GTjQiAsh0Dy5I/CIRhyYnhhc3NldGlkOi8vMTEzMDIxNzQyMTAhGHJieGFzc2V0aWQ6Ly8xMTMwMjE3NDI2MCEUTWVzaGVzL0ExMEFfZ2Vhcl9sMTEEvQHJBcoFChTp2kKOmIZA/4iYwgo1eC8+KXpGPkZUUj4hGHJieGFzc2V0aWQ6Ly8xMTMwMjEyMTI0NQogvqE7UPO2OxDgwTshGHJieGFzc2V0aWQ6Ly8xMTMwMjE'
..'yMTQ2NyETTWVzaGVzL0ExMEFfZ2Vhcl9sMgTEAckFygUKhALfQmzlhUAihpjCCil5Lz5/DSY+Br46PiEYcmJ4YXNzZXRpZDovLzExMzAyMTY4NTA5CgC/oTsAEJk7MCKsOyEYcmJ4YXNzZXRpZDovLzExMzAyMTY4NzQ3IRZNZXNoZXMvQTEwQV9haWxlcm9uMl9sBMsByQXKBQpK1+lCzI65QIwHgcIKW2OGPkqAgz4g5rI/IRhyYnhhc3NldGlkOi8vMTEzMDIxMDU1NDcKAMD3O4Bt8jte5yQ9IRhyYnhhc3NldGlkOi8vMTEzMDIxMDU3OTghFE1lc2hlcy9BMTBBX2'
..'dlYXJfYzEyBNIByQXKBQrYmbpCTGK4QJ9brMIKvNynPZYBWD4uklc+IRhyYnhhc3NldGlkOi8vMTEzMDIxNzYyNTEKALsaO7AbxzsAtcY7IRhyYnhhc3NldGlkOi8vMTEzMDIxNzY0NDkhFk1lc2hlcy9BMTBBX3dpbmdfbC4wMDUE2QHJBcoFCmZe2kLCpYVA0cKXwgoSCR1Au8BCQKOhoEAhGHJieGFzc2V0aWQ6Ly8xMTMwMjEyNzg3MwoqwJA9d4SzPbYQFD4hGHJieGFzc2V0aWQ6Ly8xMTMwMjEyODEzMSEUTWVzaGVzL0ExMEFfZnVzZS4zMDIE4AHJBcoFCl4Pw'
..'EK4sP9AdjmpwgqJ/5k+EyQLQOPnLT8hGHJieGFzc2V0aWQ6Ly8xMTMwMjEzMTA0NAp08w08iUGAPSBNoDwhGHJieGFzc2V0aWQ6Ly8xMTMwMjEzMTE3NiEUTWVzaGVzL0ExMEFfZnVzZS4xMDME5wHJBcoFCtZd5UIw89tACS6pwgqC+qNAKcH0QCTgGUIhGHJieGFzc2V0aWQ6Ly8xMTMwMjE0NzQ1NQqOJhc+h5thPoTWjT8hGHJieGFzc2V0aWQ6Ly8xMTMwMjE0NzczOSEZTWVzaGVzL0ExMEFfb3B0aWMxX3R1cnJldCEYcmJ4YXNzZXRpZDovLzExMzAyMTIzNzI2'
..'IRhyYnhhc3NldGlkOi8vMTEzMDIxMjM5ODEhFE1lc2hlcy9BMTBBX3Byb3AwMV8yBPEByQXKBQoOF/NCXpMRQfP0ssIKZeB2QJhPeEDYadk/IRhyYnhhc3NldGlkOi8vMTEzMDIxMjQ0NTcKQ5DjPb7i5D3EZ0g9IRhyYnhhc3NldGlkOi8vMTEzMDIxMjQ3NzEhEk1lc2hlcy9BMTBBX3NsYXRfcgT4AckFygUKSAneQoC5okBCArPCCmbUo0CWW60/HF3SPyEYcmJ4YXNzZXRpZDovLzExMzAyMTYxMjM0Cm0DFz7Myx89N+hBPSEYcmJ4YXNzZXRpZDovLzExMzAyMTY'
..'xMzg3IRZNZXNoZXMvQTEwQV93aW5nX2wuMDA0BP8ByQXKBQryOehCcH2OQNHCl8IKEgkdQEi9T0DmFxlBIRhyYnhhc3NldGlkOi8vMTEzMDIxMjc1MjIKKsCQPfB8vz3vHY0+IRhyYnhhc3NldGlkOi8vMTEzMDIxMjc3NTchFU1lc2hlcy9BMTBBX2JsaXN0ZXIxMQQGAskFygUK8i7IQu4kEkGgM6nCCm8nNT5AKGc/Dcw1PiEYcmJ4YXNzZXRpZDovLzExMzAyMTM2MTI4CoL7pjvsEtU8QJOnOyEYcmJ4YXNzZXRpZDovLzExMzAyMTM2MjExIRNNZXNoZXMvQTEwQV'
..'9nZWFyX3I2BA0CyQXKBQo6ON5CAG9HQIqrucIKgTrnPmEXGz8MgIw/IRhyYnhhc3NldGlkOi8vMTEzMDIxNDI5ODAKwCNVPGj1jjxKggE9IRhyYnhhc3NldGlkOi8vMTEzMDIxNDMyNDUhF01lc2hlcy9BMTBBX2JvbWJfcHlsb242BBQCyQXKBQoAbORCuC5vQFAoqcIKBWOPP289kT+6/vJAIRhyYnhhc3NldGlkOi8vMTEzMDIxODEzOTMKcysEPcDgBT1V/F8+IRhyYnhhc3NldGlkOi8vMTEzMDIxODE0NDMhE01lc2hlcy9BMTBBX2ZsYXA1X2wEGwLJBcoFCpBD6'
..'ELk0rJAelGPwgry8+49b3AdPo939T8hGHJieGFzc2V0aWQ6Ly8xMTMwMjE1NTcyOQqAQlw7cB+RO6hDYj0hGHJieGFzc2V0aWQ6Ly8xMTMwMjE1NTk1OSETTWVzaGVzL0ExMEFfZ2Vhcl9sNQQiAskFygUKbEXcQrLfh0Aku5jCCkKB4T7k4Fo/kGqfPyEYcmJ4YXNzZXRpZDovLzExMzAyMTY5NzE5CiDdTzx4wck8+vESPSEYcmJ4YXNzZXRpZDovLzExMzAyMTY5OTIwIRJNZXNoZXMvQTEwQV9nZWFyX2wEKQLJBcoFCjSS3EKgWGBAx3qYwgontmw/1TWxP9SyCkAh'
..'GHJieGFzc2V0aWQ6Ly8xMTMwMjE3NzgxMQqYMdo85FgjPUyyfz0hGHJieGFzc2V0aWQ6Ly8xMTMwMjE3ODA2MSEWTWVzaGVzL0ExMEFfd2luZ19yLjAwNAQwAskFygUKhKPpQljJwUDA48nCCkew4kH4g2RAUyJdQSEYcmJ4YXNzZXRpZDovLzExMzAyMTk5MTMzCnL0UD+Oo9I9u9XLPiEYcmJ4YXNzZXRpZDovLzExMzAyMTk5NjUxIRdNZXNoZXMvQTEwQV9haXJicmFrZV9sMwQ3AskFygUKIKjpQhi+0kA70njCCp/kdkAi91I/hO4YPyEYcmJ4YXNzZXRpZDovLzE'
..'xMzAyMTUwODg1CiiU4z0wdsI8zPeMPCEYcmJ4YXNzZXRpZDovLzExMzAyMTUxMTE4IRNNZXNoZXMvQTEwQV9nZWFyX3I4BD4CyQXKBQoCQedC5GJxQMqkusIKAo7DPtttOD9ju9o/IRhyYnhhc3NldGlkOi8vMTEzMDIxNDM4NDMKsEE0PFgAqjzmnkk9IRhyYnhhc3NldGlkOi8vMTEzMDIxNDQxMzghFk1lc2hlcy9BMTBBX2FpbGVyb24xX3IERQLJBcoFClRo6EKAAbhATmfRwgpdZm4+bCq5Plm2iT8hGHJieGFzc2V0aWQ6Ly8xMTMwMjEwNTEyMQoAwNs7KK4qPN'
..'bg/TwhGHJieGFzc2V0aWQ6Ly8xMTMwMjEwNTM3MCEUTWVzaGVzL0ExMEFfZnVzZS4wMDUETALJBcoFCnx4xUKM4upAZgepwgrNsZtANj2tQHsftkEhGHJieGFzc2V0aWQ6Ly8xMTMwMjEzOTMyOQq+gw8+zK8fPibgJz8hGHJieGFzc2V0aWQ6Ly8xMTMwMjEzOTM2MiEUTWVzaGVzL0ExMEFfZ2Vhcl9jMTMEUwLJBcoFCkskukIAjKpAR2aswgrHDQ4+V0ISPhrDtT4hGHJieGFzc2V0aWQ6Ly8xMTMwMjE3NjU2Ngro8II7QNGGOwCLJzwhGHJieGFzc2V0aWQ6Ly8xM'
..'TMwMjE3Njg5MCEQTWVzaGVzL0ExMEFfZ3VuMQRaAskFygUKOHayQnbXiEA4sqjCCl3mND8HzU8/F/i1QCEYcmJ4YXNzZXRpZDovLzExMzAyMTIyOTg4Coi/pjx0i7882LsnPiEYcmJ4YXNzZXRpZDovLzExMzAyMTIzMTc0IRRNZXNoZXMvQTEwQV9ibGlzdGVyNQRhAskFygUKsD3CQpz2tUAZraTCCh32OD7hdxNA1si0PyEYcmJ4YXNzZXRpZDovLzExMzAyMTEwODAyCvB9qjuS7oc9UKQmPSEYcmJ4YXNzZXRpZDovLzExMzAyMTExMTAyIRdNZXNoZXMvQTEwQV9h'
..'aXJicmFrZV9sNARoAskFygUKFOHpQjRMzUDYS3jCCvPKdkAPp1I/pb4aPyEYcmJ4YXNzZXRpZDovLzExMzAyMTUxMjI3CoB84z1gLMI8nKOOPCEYcmJ4YXNzZXRpZDovLzExMzAyMTUxNDg5IRNNZXNoZXMvQTEwQV9ydWRkZXIxBG8CyQXKBQqnLgxDsIERQdZEvcIKKjNBP30/F0G7m3xAIRhyYnhhc3NldGlkOi8vMTEzMDIxNTk5NjkKABayPHxqiz7Q2Og9IRhyYnhhc3NldGlkOi8vMTEzMDIxNjAyNjQhFk1lc2hlcy9BMTBBX3dpbmdfbC4wMDIEdgLJBcoFCl7'
..'56UJcPr9A8nGLwiEYcmJ4YXNzZXRpZDovLzExMzAyMTI3MjYyIRhyYnhhc3NldGlkOi8vMTEzMDIxMjczMTEhEk1lc2hlcy9BMTBBX2dlYXJfcgR7AskFygUKHpLcQjhYYEA97LnCCgh7bD/ZNbE/1LIKQCEYcmJ4YXNzZXRpZDovLzExMzAyMTcwMDMyChj72TzoWCM9TrJ/PSEYcmJ4YXNzZXRpZDovLzExMzAyMTcwMjIzIRVNZXNoZXMvQTEwQV9ydWRkZXIxXzEEggLJBcoFCidhC0O0A7VAl9+9wiEYcmJ4YXNzZXRpZDovLzExMzAyMTYwNTE2IRhyYnhhc3NldG'
..'lkOi8vMTEzMDIxNjA3ODIhFE1lc2hlcy9BMTBBX2Z1c2UuMDAzBIcCyQXKBQrGw/VC4DXEQIIzqcIKDwmdQDE2bkDArLBBIRhyYnhhc3NldGlkOi8vMTEzMDIxMzkxNTIKJ8AQPpiT2z2I2iI/IRhyYnhhc3NldGlkOi8vMTEzMDIxMzkyMDAhEE1lc2hlcy9BMTBBX2Z1c2UEjgLJBcoFCp472UKixaxA8ymowgqYL2hA+KdhQFyQFEIhGHJieGFzc2V0aWQ6Ly8xMTMwMjEzODkxMAqsBdY90gDQPRzxiD8hGHJieGFzc2V0aWQ6Ly8xMTMwMjEzODk3MCEUTWVzaGVzL'
..'0ExMEFfZnVzZS4wNTQElwLJBcoFIQpDYW5Db2xsaWRlAgrcS8RCfhMQQYIzqcIKlJjVPz/gh0AufT9AIRhyYnhhc3NldGlkOi8vMTEzMDIxNzIyNjcK8+JEPTB++j1IgrA9IRhyYnhhc3NldGlkOi8vMTEzMDIxNzI0NDchE01lc2hlcy9BMTBBX2dlYXJfbDMEngLJBcoFCiYj5EKIcF9APMKXwgomHMc+Ek4nP4Mx5j8hGHJieGFzc2V0aWQ6Ly8xMTMwMjE2ODg4OAqgiDc8gDeaPH4vVD0hGHJieGFzc2V0aWQ6Ly8xMTMwMjE2OTIwOCETTWVzaGVzL0ExMEFfZmxh'
..'cDFfcgSlAskFygUKXtztQghno0AGI7bCCk+MxEDCGTU/qfF6QCEYcmJ4YXNzZXRpZDovLzExMzAyMTgxOTM2ChgsNT7o7qY8ElDnPSEYcmJ4YXNzZXRpZDovLzExMzAyMTgyMTQ3IRRNZXNoZXMvQTEwQV9ibGlzdGVyOQSsAskFygUK+NTBQs7ctUC0AKXCCmsphj61IuQ/6fcpPyEYcmJ4YXNzZXRpZDovLzExMzAyMTM1NTAwCjBV9zvlSVI9AKycPCEYcmJ4YXNzZXRpZDovLzExMzAyMTM1NzQ4IRhNZXNoZXMvQTEwQV9ib21iX3B5bG9uMTEEswLJBcoFCqLv4kI'
..'ORaZAp2nRwiEYcmJ4YXNzZXRpZDovLzExMzAyMTEzMjUwIRhyYnhhc3NldGlkOi8vMTEzMDIxMTMyOTghFE1lc2hlcy9BMTBBX2Z1c2UuMTQzBLgCyQXKBQoB8b9CNJbsQIIzqcIKtkmVQJvI6ED7kJBBIRhyYnhhc3NldGlkOi8vMTEzMDIxNzE5NDUK9psJPrSSVj7JQQU/IRhyYnhhc3NldGlkOi8vMTEzMDIxNzIxODYhF01lc2hlcy9BMTBBX2JvbWJfcHlsb24yBL8CyQXKBQpsauNClNqWQLNWiMIhGHJieGFzc2V0aWQ6Ly8xMTMwMjE2NTczMSEYcmJ4YXNzZX'
..'RpZDovLzExMzAyMTY1ODE3IRBNZXNoZXMvQTEwQV90YWlsBMQCyQXKBQo2iwtDiODwQIIzqcIKwnKoQRBQq0B3YdRAIRhyYnhhc3NldGlkOi8vMTEzMDIxMjU5OTYKSkUbPzrpHT4sxEM+IRRNZXNoZXMvQTEwQV9wcm9wMDFfMQTKAskFygUKDhfzQl6TEUH7cZ/CIRhyYnhhc3NldGlkOi8vMTEzMDIxMjQxMjYhGHJieGFzc2V0aWQ6Ly8xMTMwMjEyNDI4OSETTWVzaGVzL0ExMEFfZ2Vhcl9sNwTPAskFygUKLBXeQlByiUAAtpjCCq6J1j7LuS4/RfyFPyEYcmJ4Y'
..'XNzZXRpZDovLzExMzAyMTIwMDc5CjDBRTycDqE89gH3PCEYcmJ4YXNzZXRpZDovLzExMzAyMTIwMzA1IRdNZXNoZXMvQTEwQV9ib21iX3B5bG9uOATWAskFygUKumTjQuh8e0CasrTCIRhyYnhhc3NldGlkOi8vMTEzMDIxODE3NzghGHJieGFzc2V0aWQ6Ly8xMTMwMjE4MTgzMSEUTWVzaGVzL0ExMEFfYmxpc3RlcjgE2wLJBcoFClapwkK0orhAtAClwgqoFY8+2EzjPw0dNT8hGHJieGFzc2V0aWQ6Ly8xMTMwMjEzNTA3MQok5AM8w4RRPfDxpjwhGHJieGFzc2V0'
..'aWQ6Ly8xMTMwMjEzNTM3MSEWTWVzaGVzL0ExMEFfd2luZ19yLjAwNQTiAskFygUKjGLaQsKlhUByur3CCmBMsUC7wEJAcyahQCEYcmJ4YXNzZXRpZDovLzExMzAyMTQ2NzM5CqttIz53hLM9IosUPiEYcmJ4YXNzZXRpZDovLzExMzAyMTQ2OTA3IRJNZXNoZXMvQTEwQV9zbGF0X2wE6QLJBcoFCkgJ3kKAuaJAxGSfwgpl1KNAllutPx9d0j8hGHJieGFzc2V0aWQ6Ly8xMTMwMjE2MDg5NApsAxc+zMsfPTjoQT0hGHJieGFzc2V0aWQ6Ly8xMTMwMjE2MTE2MyETTWV'
..'zaGVzL0ExMEFfZmxhcDVfcgTwAskFygUKYkPoQg7TskCKFcPCClLy7j1yeR0+jnf1PyEYcmJ4YXNzZXRpZDovLzExMzAyMTU2MDYzCgBBXDvAJ5E7pkNiPSEYcmJ4YXNzZXRpZDovLzExMzAyMTU2MjUxIQZMYWRkZXIEzAXNBc4FIQRQYXJ0IQVDbGljayENQm90dG9tU3VyZmFjZQMAAAAAAAAAAAT9As8F0AUKCtcjvAAAnkLsUXDBCv7zv0JGCphAZ42jwgoK1yO9AACeQgrXb8EKcCzyPwsyBUHlGeo/IQpUb3BTdXJmYWNlAwAAAAAAAPA/IQ1DbGlja0RldGVjdG'
..'9yIRVNYXhBY3RpdmF0aW9uRGlzdGFuY2UDAAAAAAAANEAhDlVuaW9uT3BlcmF0aW9uIQpCcmlja0NvbG9yB8IABAwD0QXSBSEFQ29sb3IGo6KlCgrXI7wAAJ5CCtfvQQqW479ClLidQK85o8IKCtcjvQAAnkJ7FPBBCqEC1ECMZLBAn5GpPwojvUE+mqq5P8YogT0Kksu+Qua8v0DBNaTCCie9QT7TKIE993KhPwo8/b9CiWbaQIxpo8IKwSgBPvtyoT7GKIE9CqEcv0KnzQhBntelwgoK1yO8AACeQj0KvsIKxSgBPsgogT6Dhak/CoMwwEJLw6tAoMWkwgrPfb9Cxt35P'
..'1/YoMIKJL1BPpmquT/FKIE9CrIrwUJBBaJAdDWjwgoK1yO8AACeQsP170IKEx3AQq6xAEHCDaTCCsOxvkIKBKJAqbCjwgrDKAE+/HKhPsYogT0KhgC/QiBnCEEAR6XCCgrXI7wAAJ5CPQqWwgrEKIE+tALgQMYogT0Km+rAQntvjEBZ5qHCCoJFwUIcvr9Ai7qjwgpj3b9CzmqzQEvFosIKKA3AQvLk7UCnu6PCCsEoAT7HKAE/xiiBPQojusFCX/gGQWUTpsIKCtcjvAAAnkI9CubCCjRAv0LE9wZBm46mwgpP7b9CN+nGQGcXo8IKgb2/QuhujEDfIKLCCqxwvkJEboxA'
..'j2GiwgrEKIE+/HKhPsYogT0KF82+QqV7/UArPqTCCnV6wUK7ZwhBysukwgrBjb9CPO4jQJwqocIKqJ2/QljmSkCffKHCCgZHwULcfP1A9cKjwgrDKAE++3KhPsYogT0K+Oa+Qn5zBkF7w6TCCgrXI7wAAJ5CexRcwgqQlsFCQs4IQWhcpcIKwigBPvtyoT7GKIE9CudgwUIadAZBRkikwgpxzb9CIuufQA5zosIKmq2/QrHlcUDczqHCCiS9QT77cqE+xiiBPQqP1b5CMuYCQdNppMIKCtcjvAAAnkJ7FAzCCn5PwULN5gJBnu6jwiEGU2NyaXB0IQlNYWluUGFydHME0wX'
..'UBdUFIQRTZWF0B+wDBEkD1gXXBQb/AAAhGEN1c3RvbVBoeXNpY2FsUHJvcGVydGllcxAAAMhCmpmZPgAAAD8AAIA/AACAPwoK16O8AAC0QgrXozwKXHrDQqQO3ECHPKnCCgrXozwAALRCAAAAAAreX/tANTrMP48IKUAhCUhvcHBlckJpbiEFUGxhbmUhC0xvY2FsU2NyaXB0IQRNYWluIQhEaXNhYmxlZCEHRWplY3RvciEJQm9vbFZhbHVlIQpUb29sU2VsZWN0IQlEZXNlbGVjdDAhB0d1aU1haW4hCFBsYW5lR3VpIQ5aSW5kZXhCZWhhdmlvciEKSW1hZ2VMYWJlbC'
..'EQQmFja2dyb3VuZENvbG9yMwb///8hFkJhY2tncm91bmRUcmFuc3BhcmVuY3kMAAAAP2r/AAAAAAoADAAAAAAsAQAAAABkACEHVmlzaWJsZSEFSW1hZ2UhF3JieGFzc2V0aWQ6Ly8zNTcwNjk1Nzg3IQtJbWFnZUNvbG9yMwatrK4hEUltYWdlVHJhbnNwYXJlbmN5AwAAAEAzM9M/IQlTY2FsZVR5cGUhC1NsaWNlQ2VudGVyDQAAyEIAAMhCAADIQgAAyEIhClNsaWNlU2NhbGUDAAAAoJmZqT8hBUZyYW1lIQZFbmdpbmUMmpmZPgAAmpkZPwAADAAAgD4AAM3MTD4AA'
..'CEJVGV4dExhYmVsIQRUZXh0DAAAgD8AAAAAgD8AACEERm9udAMAAAAAAAAAQCEKRW5naW5lIE9mZiEKVGV4dENvbG9yMyEIVGV4dFNpemUDAAAAAAAALEAhBVRpdGxlIQ9Cb3JkZXJTaXplUGl4ZWwMAACAPwAAAAAAAA8AIR9GYWlyY2hpbGQgUmVwdWJsaWMgQS0xMCBXYXJ0aG9nAwAAAAAAADJAIQVTcGVlZCEMQm9yZGVyQ29sb3IzBgAAAAwAAAAA//8AAAAAFAAMAAAAPwAAAAAAAA8AIQhTcGVlZDogMCEIQWx0aXR1ZGUMAAAAPwEAAAAAABQAIQtBbHRpdHVk'
..'ZTogMCEER2VhcgwK1yM8AACamRk/AAAhCUdlYXIgRG93biEIVGhyb3R0bGUMj8L1PAAAAAAAACgAIQdQZXJjZW50DAAAAADIAAAAAAAAAAwAAAAAKAAAAIA/AAAhBDEwMCUhC1RleHRXcmFwcGVkIQNCYXIGRkZGDAAAAAA8AAAAAD/8/wwAAAAAUAAAAAAACQAhBFRyYXkhCkJvcmRlck1vZGUMAAAAAAAAAACAPwAADAAAAAA8AAAAgD8AACEJVGhyb3R0bGU6IQVTdGFsbAwAAAAAYP8AAAAAAAAMAAAAAJYAAAAAAFUAIQVTdHlsZQMAAAAAAAAYQCENU1RBTEwgV0F'
..'STklORwMAAAAAAAA4QCEEVGF4aQwAAAAAJwEAAAAAAAAhB1RBWElJTkchBlB1bGxVcAwAAAAAAAAAAAAAXwAMAACAPwAAAAAAACgAIQdQdWxsIFVwIQ1Db250cm9sc0ZyYW1lDAAAAAAAAAAAAAAy/wwAAIA/AAAAAAAAlgADAAAAAAAACEAhAkM1DAAAAAAAAAAAAABkAAwAAAA/AAAAAAAACgAhClRvZ2dsZSBIVUQhFlRleHRTdHJva2VUcmFuc3BhcmVuY3khDlRleHRYQWxpZ25tZW50IQNLZXkMAACAPwAAAAAAAAAAIQRLZXk6IQJDNgwAAAAAAAAAAAAAeAAhBU'
..'VqZWN0DAAAgD8AAAAAAAAKACEPRmxpZ2h0IENvbnRyb2xzIQRMaW5lBlX/AAwAAAA/+v8AAIA/BQAMAAAAAAIAAAAAAHgAIQAhAkMxDAAAAAAAAAAAAAAUACECQzMMAAAAAAAAAAAAADwAIQpEZWNlbGVyYXRlIQJDNAwAAAAAAAAAAAAAUAAhDExhbmRpbmcgR2VhciECQzIMAAAAAAAAAAAAACgAIQpBY2NlbGVyYXRlIRRtaXNzaWxlX3N5c3RlbV9sb2NhbCEMQmlsbGJvYXJkR3VpIQlUYXJnZXRpbmchB0VuYWJsZWQhBkFjdGl2ZSELQWx3YXlzT25Ub3AhEENsa'
..'XBzRGVzY2VuZGFudHMhDkxpZ2h0SW5mbHVlbmNlAwAAAAAAAPC/DAAAIEEUAAAAIEEUACELR3JlZW5DaXJjbGUhF3JieGFzc2V0aWQ6Ly81ODgzNjQxNTU0BgD/ACELT2JqZWN0VmFsdWUhBVZhbHVlIQtSZW1vdGVFdmVudCEJRmlyZUV2ZW50IRVtaXNzaWxlX3N5c3RlbV9zZXJ2ZXIhCk1pc3NpbGVQb3MhEVB1dFRoaXNJbk1haW5TZWF0IQlCbG9ja01lc2ghD09wZXJhdGlvblNjcmlwdCENQ29uZmlndXJhdGlvbiELTnVtYmVyVmFsdWUhCkhlYWQgQW5nbGUh'
..'CkxlZ3MgQW5nbGUhCkFybXMgQW5nbGUDAAAAAAAAPkAhDVNpdHRpbmcgQW5nbGUhDFZlY3RvcjNWYWx1ZSEQU2l0dGluZyBQb3NpdGlvbiELRGVzZWxlY3RpbmchBVNvdW5kIQRHUFdTIQZMb29wZWQhElJvbGxPZmZNYXhEaXN0YW5jZQMAAAAAAAAkQCELUm9sbE9mZk1vZGUhB1NvdW5kSWQhF3JieGFzc2V0aWQ6Ly8zNjExMDMwMDQzIQZWb2x1bWUhBlRhcmdldCEHTWlzc2lsZSENUGxheWJhY2tTcGVlZAMAAACgmZnpPyEXcmJ4YXNzZXRpZDovLzU4OTY0MzQ'
..'0NzghBUdpdmVyB+kDBPsD2AXZBQb4+PgKAAAAAAAAtEIAADRCCmYq5UI44sA/Jr+PwgoAADRCAAC0QgAAAAAKt1YKQLdWCkC3VgpBISdodHRwOi8vd3d3LnJvYmxveC5jb20vYXNzZXQvP2lkPTIyNTE1MzQKw4FeQMOBXkCsi1JBIQtCYWNrU3VyZmFjZQQEBNoF2wUhDEZyb250U3VyZmFjZSELTGVmdFN1cmZhY2UKporoQpja30D4F6nCIQxSaWdodFN1cmZhY2UKZeysQLdWij95X4RBIQhCb2R5R3lybyEJRGlyZWN0aW9uIQlNYXhUb3JxdWUKAAAAAAAAAAAAAA'
..'AAIQxCb2R5VmVsb2NpdHkhBlRocnVzdCEITWF4Rm9yY2UhAVAhCFZlbG9jaXR5IQtFbmdpbmVTb3VuZCEHUGxheWluZwMAAAAAAFi7QCESUm9sbE9mZk1pbkRpc3RhbmNlAwAAAAAAAFlAIRdyYnhhc3NldGlkOi8vNTYyMzEwNTc1OSEFUGl0Y2ghBFJvbGwhA0d1bgQaBNwF3QUKITysQrYfiEDis6jCCrdWCj+3Vgo/t1YKPyEPUGFydGljbGVFbWl0dGVyIQREcmFnAwAAAAAAAC5AIRFFbWlzc2lvbkRpcmVjdGlvbgMAAAAAAAAUQCEITGlmZXRpbWURAAAAQAAAA'
..'EAhBFJhdGUDAAAAAAAAaUARAAC0wwAAtEMpAwAAAAAAAIA/AAAAAJqZmT4AAABBAAAAAAAAgD8AACBBAAAAABEAAEhCAABIQyELU3ByZWFkQW5nbGULAACgQAAAoEAhB1RleHR1cmUhLHJieGFzc2V0Oi8vdGV4dHVyZXMvcGFydGljbGVzL3Ntb2tlX21haW4uZGRzKQIAAAAAZmZmPwAAAAAAAIA/AACAPwAAAAAhFnJieGFzc2V0aWQ6Ly8zODYwNTY5OTghBEJvb20hA0hVRAQyBN4F3wUKAADoQAAAtEIAAAAACstivUJ6FhxB7yypwgoAALRCAIClQgAAtMIKXBol'
..'P5mjEj8bwpI9IQpTdXJmYWNlR3VpIQRGYWNlIQ1QaXhlbHNQZXJTdHVkAwAAAAAAQH9AIQpTaXppbmdNb2RlIQdaT2Zmc2V0BmT/ZAwK16M7AAAAAIA/AAAMzczMPgAAAAAAPwAADM3MTD4AAArXIzwAAAyuR+E9AAAAAAAAAAAMzcxMPwAAAACAPwAADM3MTD0AAAAAAD8AAAwAAIA+AAAK1yM8AAAMAACAPgAAAACgwQAADAAAQD8AADMzMz8AAAwAACBAAAAAACBCAAAMAACAPgAAAACgQQAADAAAIEAAAAAAAAAAAAwAACBAAAAAAKBBAAAMAAAgQAAAAACgwQAADAA'
..'AgD4AAAAAIEIAACEBMQwAAIA+AAAAACDCAAAMAAAgQAAAAAAgwgAADAAAgD4AAAAAcMIAAAwAACBAAAAAAHDCAAAMAAAgQAAAAACgwgAADAAAgD4AAAAAoMIAAAwAACBAAAAAAHBCAAAMAACAPgAAAABwQgAADAAAIEAAAAAAoEIAAAwAAIA+AAAAAKBCAAAMAAAgQAAAAADIwgAADAAAgD4AAAAAyMIAAAwAACBAAAAAAPDCAAAMAACAPgAAAADwwgAADAAAgD4AAAAAyEIAAAwAACBAAAAAAMhCAAAMAAAgQAAAAADwQgAADAAAgD4AAAAA8EIAAAwK16M8AAAAAAAAAA'
..'AMj8L1PQAAzczMPQAAIQM1MDADAAAAAAAAOUAMCtejPAAAAACAPgAADArXozsAAAAAAD8AAAzNzMw9AAAAAAAAAAAMAABAPwAACtejOwAADKRw/T4AAAAAgD8AAAwK1yM8AAAAAKBAAAAMZmZmPwAAAAAAAAAADI/C9TwAAB+F6z4AAAyPwvU8AABmZmY/AAAEbQTgBeEFCgAAAAAAALRCCtejvAqulPtCHMEBQShJqcIKCtejvAAAtEIAAAAACrdWij+3Voo/t1aKPyEXcmJ4YXNzZXRpZDovLzU2MjU3MTMwNzchFEVxdWFsaXplclNvdW5kRWZmZWN0IQhEaXN0YW5jZ'
..'SEISGlnaEdhaW4DAAAAAAAAVMAhB0xvd0dhaW4hB01pZEdhaW4hA2V2dCEFZmxhcmUEfATiBeMFEDMzMz+amZk+AAAAPwAAgD8AAIA/CgAAtMI9CrTCAAAAAAptxQVDoGJ7QIg4qcIKPQq0wgAAAAA9CrTCCqkBpj6pAaY+qQGmPgMAAABgZmbmPwMAAAAAAECPQCEXcmJ4YXNzZXRpZDovLzQxNzk0OTY0NjIhDlBpdm90RWxldmF0b3JzBIUE5AXlBQoK16O8AAA0QwrXo7wKEB4MQ/a8vEDqbqnCCuH6M8MAAAAA4fozQwq3Voo/t1aKP22pjkEhCUVsZXZhdG9ycwTm'
..'BecF6AUEiwTpBeoFCssdDEMTvbxAYG6pwiEHTW90b3I2RCEFTW90b3IhAkMwBAoE6wXsBQTtBe4F7wUhBVBhcnQwIQVQYXJ0MSELTWF4VmVsb2NpdHkDAAAAQOF6lD8hFU1lc2hlcy9BMTBBX2VsZXZhdG9yMASXBMkFygUKO30MQx78tEAuap7CCvTsBkG8VSA/KbYlQCEYcmJ4YXNzZXRpZDovLzExMzAyMTEzNDQ4Cqq9eD7AypM8gL+YPSEYcmJ4YXNzZXRpZDovLzExMzAyMTEzNzU3IRVNZXNoZXMvQTEwQV9lbGV2YXRvcjEEngTJBcoFCjt9DEMe/LRA2PyzwiE'
..'YcmJ4YXNzZXRpZDovLzExMzAyMTEzODc3IRhyYnhhc3NldGlkOi8vMTEzMDIxMTQxMTQhD3FQZXJmZWN0aW9uV2VsZCEIQWlsZXJvbnME8AXxBfIFIQFMBKcE8wX0BQoK16O8AACgwArXI7wKnx/pQvPC6UBQJn/CCotX3T6LV90+Oe3/QAQKBPUF9gUE9wX4BfkFIQFSBK4E+gX7BQoK16O8AADwQArXIzwKCx/pQntE6UAgdNPCBAoE/AX9BQT3BfwF/QUhCExBaWxlcm9uBP4F1AXVBSEWTWVzaGVzL0ExMEFfYWlyYnJha2VfbAS2BNQF1QUKAADwQXuUqUIAAAAACj'
..'hF7EKEgdFAQw95wgq4HqJCKVxuQuxRn8IKa/8kQczd6j81TUNAIRhyYnhhc3NldGlkOi8vMTEzMDIxNjQwMDQKDheYPjB+WD30BbQ9IRhyYnhhc3NldGlkOi8vMTEzMDIxNjQzMDQhF01lc2hlcy9BMTBBX2FpcmJyYWtlX2wxBL4E1AXVBQrK2OtCpoPOQEALecIKOgElQbrmDECDeiFAIRhyYnhhc3NldGlkOi8vMTEzMDIxNjQ0NjgKuBiYPu/ggT2f2JQ9IRhyYnhhc3NldGlkOi8vMTEzMDIxNjQ2NzAhFU1lc2hlcy9BMTBBX2FpbGVyb25fbATGBP8FygUKAAAAA'
..'ACAsEIAAAAACjQP6ULs8dBAuLB4wgrkNSZB4MMCQGPe9T8hGHJieGFzc2V0aWQ6Ly8xMTMwMjEwNjMyMwo9NZk+KBJxPXGiYj0hGHJieGFzc2V0aWQ6Ly8xMTMwMjEwNjU4OAQABgEGAgYhCFJBaWxlcm9uBAMGyQUEBiEWTWVzaGVzL0ExMEFfYWlyYnJha2VfcgTRBMkFBAYKH4WPwQAAtEIAAAAACgoD7UII7dJAFRvWwgoAALTCuB6QQgAAtEIKYtEkQXwsNEDz2jZAIRhyYnhhc3NldGlkOi8vMTEzMDIxNTE2MDMKn+yXPjAUpj31jKg9IRhyYnhhc3NldGlkOi8v'
..'MTEzMDIxNTE4NDEhF01lc2hlcy9BMTBBX2FpcmJyYWtlX3IxBNkEyQUEBgpUmOxCtCrOQJoc1sIKiL4kQcugCkBX2SJAIRhyYnhhc3NldGlkOi8vMTEzMDIxNTE5NzUKP9uXPg2Rfz0CHJY9IRhyYnhhc3NldGlkOi8vMTEzMDIxNTIyMDQhF01lc2hlcy9BMTBBX2FpcmJyYWtlX3I0BOAEyQXKBQpGq+lCDPXXQL8p1sIKxjJ2QCZZPD/SdSQ/IRhyYnhhc3NldGlkOi8vMTEzMDIxNTI2NTkKOPDiPSadrTw4mJc8IRhyYnhhc3NldGlkOi8vMTEzMDIxNTI4ODchF01'
..'lc2hlcy9BMTBBX2FpcmJyYWtlX3IzBOcEyQXKBQoS1+lC2L3eQArk1cIKhCd2QDDOOj+KcSM/IRhyYnhhc3NldGlkOi8vMTEzMDIxNTIzNTUK2OXiPRYxrDxMqJY8IRhyYnhhc3NldGlkOi8vMTEzMDIxNTI1NTchFU1lc2hlcy9BMTBBX2FpbGVyb25fcgTuBAUGBgYKqsjoQs4V0EBx9NXCCkODJEHQpwBApBEcQCEYcmJ4YXNzZXRpZDovLzExMzAyMTA2NzQ1Cpyklz6GLm09F9yPPSEYcmJ4YXNzZXRpZDovLzExMzAyMTA2OTg1BAcGCAYJBiEGUGl2b3RMBPYECg'
..'YLBgqeH+lCxLboQE8mf8IhBlBpdm90UgT5BAwGDQYKDB/pQkw46EAfdNPCIQZDYW5vcHkEDgYPBhAGIQtDYW5vcHlDbG9zZSEBcAQABREGEgYKAAAAAAAANMNx/TPDCr5rzkJCSx9BSy2pwgoAADTDAAAAAArXIzwKqQGmPqcBpj5m7CxAIQxEZXNpcmVkQW5nbGUDAAAAoJmZ4T8DAAAAQOF6hD8hBUNvdmVyBBMGEQYSBiEDQXR0IRRNZXNoZXMvQTEwQV9ibGlzdGVyMQQLBckFygUKiIXGQipkIkGPM6nCCivJREBVhx1AhZDjQCEYcmJ4YXNzZXRpZDovLzExMzAyM'
..'TA4NzI5CjFktT2MNJE9JsNRPiEYTWVzaGVzL0ExMEFfYmxpc3RlcjEuMDAyBBEFyQXKBQoW08ZCViAfQY8zqcIKtn1kQA8zN0DrWPhAIRhyYnhhc3NldGlkOi8vMTEzMDIxMDk0OTUKyJ3SPSzeqD1W62Q+IRhyYnhhc3NldGlkOi8vMTEzMDIxMDk2NzghGE1lc2hlcy9BMTBBX2JsaXN0ZXIxLjAwMQQYBckFygUKxtHGQjAEHUGPM6nCCrZ9ZEAd3yVAHC/4QCEYcmJ4YXNzZXRpZDovLzExMzAyMTA4ODk5Csid0j0/5Zg9zMRkPiEYcmJ4YXNzZXRpZDovLzExMzAy'
..'MTA5Mjg3BBQGyQXKBSEITWFpbkdlYXIEFQbJBcoFIRNNZXNoZXMvQTEwQV9nZWFyX3IxBCMFyQXKBRAAAMhCMzOzPs3MTD0AAIA/AACAPwrYsuJCPPNnQLNousIKj2TPPxBC0j+sEYtAIRhyYnhhc3NldGlkOi8vMTEzMDIxNzgxNzMKKCs/PUjPQT2TMAA+IRhyYnhhc3NldGlkOi8vMTEzMDIxNzgzNzIhE01lc2hlcy9BMTBBX3doZWVsX3IEKgXJBcoFCnaj20J85FxAxWS7wgrYuYg/olhBQGk5QUAhGHJieGFzc2V0aWQ6Ly8xMTMwMjE5NTczMwpYD/w8ijiyPcI'
..'bsj0hGHJieGFzc2V0aWQ6Ly8xMTMwMjE5NjE4NyETTWVzaGVzL0ExMEFfZ2Vhcl9yOQQxBckFygUKSuXlQpwOWkChOrrCCuNFuD8WSzw/43VhQCEYcmJ4YXNzZXRpZDovLzExMzAyMTQ0MjQ0CoDbKT0wkK08ptLPPSEYcmJ4YXNzZXRpZDovLzExMzAyMTQ0NDQyIRNNZXNoZXMvQTEwQV9nZWFyX3I0BDgFyQXKBQpwL91CDEc4QNd0ucIK+K0qP2/k8z7irQRAIRhyYnhhc3NldGlkOi8vMTEzMDIxOTI3MjUK0FOdPBDQYDyCmXQ9IRhyYnhhc3NldGlkOi8vMTEzMD'
..'IxOTMzMzchA2F0dAQ/BRYGFwYKjFnnQlLegkBwfbrCBBgGyQXKBSETTWVzaGVzL0ExMEFfd2hlZWxfbARDBckFygUKiqPbQujkXEA/ApfCCvO5iD+gWEFAaTlBQCEYcmJ4YXNzZXRpZDovLzExMzAyMTk0OTA3CogP/DyJOLI9wxuyPSEYcmJ4YXNzZXRpZDovLzExMzAyMTk1Mzc5IRNNZXNoZXMvQTEwQV9nZWFyX2w0BEoFyQXKBQqGL91CIEk4QC3ymMIK760qPwRw8z5qsQRAIRhyYnhhc3NldGlkOi8vMTEzMDIxNjk0MTIKyFOdPMBkYDwBoHQ9IRhyYnhhc3Nld'
..'GlkOi8vMTEzMDIxNjk2MTEhE01lc2hlcy9BMTBBX2dlYXJfbDkEUQXJBcoFCgrl5UKcDlpAYiyYwgrIRbg/U0s8P3N2YUAhGHJieGFzc2V0aWQ6Ly8xMTMwMjEyMDY3Ngpo2yk9aJCtPCzTzz0hGHJieGFzc2V0aWQ6Ly8xMTMwMjEyMDk3MiETTWVzaGVzL0ExMEFfZ2Vhcl9sMQRYBckFygUK2LLiQjzzZ0Bc/pfCCu1Fzz8QQtI/rhGLQCEYcmJ4YXNzZXRpZDovLzExMzAyMTY4MTIxCuwOPz1Iz0E9lDAAPiEYcmJ4YXNzZXRpZDovLzExMzAyMTY4MzIyBF4FFgYX'
..'BgqMWedCUt6CQH7il8IEGQbJBcoFIRNNZXNoZXMvQTEwQV9nZWFyX2M1BGIFyQXKBQrw2sJChp2GQM40q8IKgfjNPjOkCD/JSwFAIRhyYnhhc3NldGlkOi8vMTEzMDIxMTczMzEKlts9PHDnezzQXG49IRhyYnhhc3NldGlkOi8vMTEzMDIxMTc1NDQhE01lc2hlcy9BMTBBX2dlYXJfYzgEaQXJBcoFCji7vkJgLopA5DSrwgrTrPI+CeE/P5myuz8hGHJieGFzc2V0aWQ6Ly8xMTMwMjEzOTc1NArWsF88VN6wPKADLT0hGHJieGFzc2V0aWQ6Ly8xMTMwMjEzOTk3OSE'
..'TTWVzaGVzL0ExMEFfZ2Vhcl9jNARwBckFygUKdSe/QkhPjEDONKvCCtkWjj7Xlts+U3/hPyEYcmJ4YXNzZXRpZDovLzExMzAyMTE3MDYyCkT5AjwwaUo8WNtPPSEYcmJ4YXNzZXRpZDovLzExMzAyMTE3MjQ5IRNNZXNoZXMvQTEwQV9nZWFyX2MyBHcFyQXKBQrod7lC9m2SQO00q8IKrYSZPgYL+D528WM/IRhyYnhhc3NldGlkOi8vMTEzMDIxMTYyNTgKNIINPIijZDyAHNI8IRhyYnhhc3NldGlkOi8vMTEzMDIxMTY0ODQhE01lc2hlcy9BMTBBX2dlYXJfYzMEfg'
..'XJBcoFClcKu0IoLY9AazSrwgqthJk+1cmPPpQ6cz8hGHJieGFzc2V0aWQ6Ly8xMTMwMjExNjYzNgo0gg08OIoEPIAz4DwhGHJieGFzc2V0aWQ6Ly8xMTMwMjExNjk4NCESTWVzaGVzL0ExMEFfZ2Vhcl9jBIUFyQXKBQrBkbhCwjOiQJOBq8IKy36FPw8JVD9RJzxAIRhyYnhhc3NldGlkOi8vMTEzMDIxMzk0NzIKoxr2PLBywzw4b609IRhyYnhhc3NldGlkOi8vMTEzMDIxMzk2NzMhF01lc2hlcy9BMTBBX2dlYXJfYzEuMDAxBIwFyQXKBQr58r5CapujQJyjq8IKM'
..'Gm1P3mCxT/AUnlAIRhyYnhhc3NldGlkOi8vMTEzMDIxMzIyNDAKHjgnPQAPNj2g0eU9IRhyYnhhc3NldGlkOi8vMTEzMDIxMzI0MjchE01lc2hlcy9BMTBBX2dlYXJfYzEElQXJBcoFEAAAyEKamZk+zcxMPgAAgD8AAIA/AwAAAAAAAHJACq23vUIYO6xA156rwgr7dmI/9soGP8FiJkAhGHJieGFzc2V0aWQ6Ly8xMTMwMjExNjE3OQqhv9A8AH94PJhemT0hFE1lc2hlcy9BMTBBX2dlYXJfYzE0BJsFyQXKBQpX27lCblyxQIA0q8IKJ+v3PRklAj8yUJw/IRhyYnhh'
..'c3NldGlkOi8vMTEzMDIxNzcwOTIKKIZkO3DtbzzAFRA9IRhyYnhhc3NldGlkOi8vMTEzMDIxNzczMzchF01lc2hlcy9BMTBBX3doZWVsX2MuMTg5BKIFyQXKBQp0+7VCiuSjQGc0q8IK+REtP5nvAUAO6wFAIRhyYnhhc3NldGlkOi8vMTEzMDIxMzEzNzkK8IefPNCKbz1wgm89IRhyYnhhc3NldGlkOi8vMTEzMDIxMzE2NzEhF01lc2hlcy9BMTBBX3doZWVsX2MuMjM0BKkFyQXKBQp0+7VCGOGjQGc0q8IK7kLcPrmtRz/KrUc/IRhyYnhhc3NldGlkOi8vMTEzMDI'
..'xMzE4NTkK0AdLPNAOuDzgDrg8IRhyYnhhc3NldGlkOi8vMTEzMDIxMzIwNTAErwUWBhcGCh7AwkIgnpNA6SerwiEIR2VhckRvb3IEGgbJBcoFIRNNZXNoZXMvQTEwQV9nZWFyX2M3BLQFyQXKBQonysFC/N57QLaoq8IKwIijPzgPoD4JXYlAIRhyYnhhc3NldGlkOi8vMTEzMDIxMTgwOTkKsr0WPcCJEzwwPP09IRhyYnhhc3NldGlkOi8vMTEzMDIxMTgzMTQhE01lc2hlcy9BMTBBX2dlYXJfYzYEuwXJBcoFCoeduELmVIVAjbarwgqKjao/qd05P09CnEAhGHJieG'
..'Fzc2V0aWQ6Ly8xMTMwMjExNzcwMQrsNR09YFOrPPQIED4hGHJieGFzc2V0aWQ6Ly8xMTMwMjExNzk3OQTCBRsGFwYKAAAAAAAAtMIAAAAACuTyuUKEdoRAQr+swiEKR2VhckRQaXZvdCEDQW5nAzMzMzMzM/u/IQlHZWFyUGl2b3QDmpmZmZmZ+T8K+D/lQvByAkGCM6nCCgAAAABTk7+QAACAvwqgnQKdAACAP1OTv5AK+D/lQtT5/UCCM6nCClTyv0I4CphA4oyjwgoCLSk+sM3/PlCwWb8KhGvDvV3CXT9GGPs+Cha5PD6gsIS+LLZyvwqxEUo99kB3P6hDgr4KCSspP'
..'nLX/z6LrVm/CkNzw72Mv10/1yH7Pgr4w+dC8A+iQNOSqcIK8RW6PWrjPRva8H6/Ctrw/j7Xs10/8RU6PQrpFoY3XuOJOSQAgL8KYF2Juf7/fz++4ok5CncLS7LCBDU/WQU1vwolCyoyJgU1P/UENT8KHOiDshewVzAkAIC/CqKsurAAAIA/F7BXsAqb5gOzov+jMQAAgL8KV/BXsQAAgD+j/6MxCj5CALPN7hMyAACAvwpqPQE+8PN9P6P/ozEKAeeDskD8wbkkAIC/CkxVSbgAAIA/rfzBuQq+Qr25aLTGOSMAgD8KJACAP5m2urDfRr05CiQAgL8U44m53ViGtwop5Im5'
..'/v9/P07jiTkKm+EMQ6a+vECaW6nCCu6jdrfh54m5AACAPwp8/om5//9/P1vniTkKJACAv/jhibnK14G3CgnjibkAAIA/4+KJOQoAAIA/ACCWMsIyzbcKg18Isf7/fz9rBiY6CrZWijq/F3I3tlaKugoAAIA/AGDeMtSz0bcK6r8ssv7/fz+hBiY6Cn4860Kk0ehA93GpwgqvUUC4suSJuQAAgD8KCXqJuf7/fz8U44k5CgUHfz8c+uy4BmmyPQoThRY5AQCAP9GStLkKAACAP5t1L7D9/5+0CoR1LzAAAIA/+/+lsQoAAAAAdRcGPQAAAAAK//9/P+CJaDAAAKC0CmPtoLA'
..'BAIA/AABgJQrBz30/ymRgOWOjBb4Kri2EuQIAgD9kbpC5Cv7/fz9p8Ji0AACQNAqT/pg0AQCAPx8mlbMKIEjqQhCPyUB4xXjCCu6C+jxfoX8aS+F/vwplus4/N4hGP4D8jbwKtd9nvRz67Lghl38/CmnKtjkBAIA/2mcLOQqOOOtCBmnMQF8K1sIKWredvjiNcz+GQraQCgAAQDMAAJCwQACAvwqpt52+Qo1zPwAAoDIK4BOgv8BbMj/OSs4+CmOjBT6DQ5y+iXxxPwpkbpA5U5JzP+yXnT4KIwd/P+n67LgbabI9Cr2FFjkAAIA/hZO0uQrFz30/yGRgOWOjBb4Ksi2EuQ'
..'AAgD90bpC5CsBrzkJCSx9BSi2pwgoAAIA/3rwppgAAwCAKIL0ppgEAgD9Uk7+QCgAAgD+eU8m4aJAYswqcU8m4AgCAv53+FpoKwGvOQkJLH0FLLanCCkyTzkJEPoFAgjOpwgrYBOFCgORcQBGgusIKAACAP6SdAh0AAAAACpydAp0AAIA/U5O/kArEBOFC6ORcQNzGl8IKoUC9QoAvnUCco6vCCijKwUL83ntAtqirwgoAAAAAU5O/EAAAgD+5AQEAAAACAAIAAwAEAAUAAQABAAIAAgAGAAQABwAIAAIADAACAAkACgALAAwADQAOAAsADwAQABEAEgATABQAFQASABYAF'
..'wAYABkAGgAbABwAHQAIAAIADAACAB4ACgALAAwAHwAOAAsADwAQABEAEgATACAAFQASABYAIQAYACIAGgAjABwAJAAIAAIADAACACUACgALAAwAJgAOAAsADwAQABEAEgATACcAFQASABYAKAAYACkAGgAqABwAKwAIAAIADAACACwACgALAAwALQAOAAsADwAQABEAEgATAC4AFQASABYALwAYADAAGgAxABwAMgAIAAIADAACADMACgALAAwANAAOAAsADwAQABEAEgATADUAFQASABYANgAYADcAGgA4ABwAOQAIAAIADAACADoACgALAAwAOwAOAAsADwAQABEAEgAT'
..'ADwAFQASABYAPQAYAD4AGgA/ABwAQAAIAAIADAACAEEACgALAAwAQgAOAAsADwAQABEAEgATAEMAFQASABYARAAYAEUAGgBGABwARwAIAAIADAACAEgACgALAAwASQAOAAsADwAQABEAEgATAEoAFQASABYASwAYAEwAGgBNABwATgAIAAIADAACAE8ACgALAAwAUAAOAAsADwAQABEAEgATAFEAFQASABYAUgAYAFMAGgBUABwAVQAIAAIADAACAFYACgALAAwAVwAOAAsADwAQABEAEgATAFgAFQASABYAWQAYAFoAGgBbABwAXAAIAAIADAACAF0ACgALAAwAXgAOAAs'
..'ADwAQABEAEgATAF8AFQASABYAYAAYAGEAGgBiABwAYwAIAAIADAACAGQACgALAAwAZQAOAAsADwAQABEAEgATAGYAFQASABYAZwAYAGgAGgBpABwAagAIAAIADAACAGsACgALAAwAbAAOAAsADwAQABEAEgATAG0AFQASABYAbgAYAG8AGgBwABwAcQAIAAIADAACAHIACgALAAwAcwAOAAsADwAQABEAEgATAHQAFQASABYAdQAYAHYAGgB3ABwAeAAIAAIADAACAHkACgALAAwAegAOAAsADwB7ABEAEgATAHwAFQASABYAfQB+AH8AGACAABoAgQAIAAIADAACAIIACg'
..'ALAAwAgwAOAAsADwAQABEAEgATAIQAFQASABYAKAAYAIUAGgAqABwAhgAIAAIADAACAIcACgALAAwAiAAOAAsADwAQABEAEgATAIkAFQASABYAigAYAIsAGgCMABwAjQAIAAIADAACAI4ACgALAAwAjwAOAAsADwAQABEAEgATAJAAFQASABYAkQAYAJIAGgCTABwAlAAIAAIADAACAJUACgALAAwAlgAOAAsADwAQABEAEgATAJcAFQASABYAmAAYAJkAGgCaABwAmwAIAAIADAACAJwACgALAAwAnQAOAAsADwAQABEAEgATAJ4AFQASABYAnwAYAKAAGgChABwAogAIA'
..'AIADAACAKMACgALAAwApAAOAAsADwAQABEAEgATAKUAFQASABYApgAYAKcAGgCoABwAqQAIAAIADAACAKoACgALAAwAqwAOAAsADwAQABEAEgATAKwAFQASABYArQAYAK4AGgCvABwAsAAIAAIADAACALEACgALAAwAsgAOAAsADwAQABEAEgATALMAFQASABYAtAAYALUAGgC2ABwAtwAIAAIADAACALgACgALAAwAuQAOAAsADwAQABEAEgATALoAFQASABYAuwAYALwAGgC9ABwAvgAIAAIADAACAL8ACgALAAwAwAAOAAsADwAQABEAEgATAMEAFQASABYAwgAYAMMA'
..'GgDEABwAxQAIAAIADAACAMYACgALAAwAxwAOAAsADwAQABEAEgATAMgAFQASABYAyQAYAMoAGgDLABwAzAAIAAIADAACAM0ACgALAAwAzgAOAAsADwAQABEAEgATAM8AFQASABYA0AAYANEAGgDSABwA0wAIAAIADAACANQACgALAAwA1QAOAAsADwAQABEAEgATANYAFQASABYA1wAYANgAGgDZABwA2gAIAAIADAACANsACgALAAwA3AAOAAsADwAQABEAEgATAN0AFQASABYA3gAYAN8AGgDgABwA4QAIAAIADAACAOIACgALAAwA4wAOAAsADwAQABEAEgATAOQAFQA'
..'SABYA5QAYAOYAGgDnABwA6AAIAAIADAACAOkACgALAAwA6gAOAAsADwAQABEAEgATAOsAFQASABYA7AAYAO0AGgDuABwA7wAIAAIADAACAPAACgALAAwA8QAOAAsADwAQABEAEgATAPIAFQASABYA8wAYAPQAGgD1ABwA9gAIAAIADAACAPcACgALAAwA+AAOAAsADwAQABEAEgATAPkAFQASABYA+gAYAPsAGgD8ABwA/QAIAAIADAACAP4ACgALAAwA/wAOAAsADwAQABEAEgATAAABFQASABYAAQEYAAIBGgADARwABAEIAAIADAACAAUBCgALAAwABgEOAAsADwAQAB'
..'EAEgATAAcBFQASABYACAEYAAkBGgAKARwACwEIAAIADAACAAwBCgALAAwADQEOAAsADwAQABEAEgATAA4BFQASABYADwEYABABGgARARwAEgEIAAIADAACABMBCgALAAwAFAEOAAsADwAQABEAEgATABUBFQASABYAFgEYABcBGgAYARwAGQEIAAIADAACABoBCgALAAwAGwEOAAsADwAQABEAEgATABwBFQASABYAHQEYAB4BGgAfARwAIAEIAAIACwACACEBCgALAAwAIgEOAAsADwAQABEAEgATACMBFQASABYAJAEYACUBGgAmAQgAAgAMAAIAJwEKAAsADAAoAQ4AC'
..'wAPABAAEQASABMAKQEVABIAFgCfABgAKgEaAKEAHAArAQgAAgAMAAIALAEKAAsADAAtAQ4ACwAPABAAEQASABMALgEVABIAFgAhABgALwEaACMAHAAwAQgAAgALAAIAMQEKAAsADAAyAQ4ACwAPABAAEQASABMAMwEVABIAFgAkARgANAEaACYBCAACAAwAAgA1AQoACwAMADYBDgALAA8AEAARABIAEwA3ARUAEgAWADgBGAA5ARoAOgEcADsBCAACAAwAAgA8AQoACwAMAD0BDgALAA8AEAARABIAEwA+ARUAEgAWAD8BGABAARoAQQEcAEIBCAACAAwAAgBDAQoACwAM'
..'AEQBDgALAA8AEAARABIAEwBFARUAEgAWAEYBGABHARoASAEcAEkBCAACAAwAAgBKAQoACwAMAEsBDgALAA8AEAARABIAEwBMARUAEgAWAE0BGABOARoATwEcAFABCAACAAwAAgBRAQoACwAMAFIBDgALAA8AEAARABIAEwBTARUAEgAWAFQBGABVARoAVgEcAFcBCAACAAwAAgBYAQoACwAMAFkBDgALAA8AEAARABIAEwBaARUAEgAWAFsBGABcARoAXQEcAF4BCAACAAwAAgBfAQoACwAMAGABDgALAA8AEAARABIAEwBhARUAEgAWAGIBGABjARoAZAEcAGUBCAACAAw'
..'AAgBmAQoACwAMAGcBDgALAA8AEAARABIAEwBoARUAEgAWAEQAGABpARoARgAcAGoBCAACAAwAAgBrAQoACwAMAGwBDgALAA8AEAARABIAEwBtARUAEgAWAG4BGABvARoAcAEcAHEBCAACAAwAAgByAQoACwAMAHMBDgALAA8AEAARABIAEwB0ARUAEgAWAHUBGAB2ARoAdwEcAHgBCAACAAwAAgB5AQoACwAMAHoBDgALAA8AEAARABIAEwB7ARUAEgAWANcAGAB8ARoA2QAcAH0BCAACAAwAAgB+AQoACwAMAH8BDgALAA8AEAARABIAEwCAARUAEgAWAIEBGACCARoAgw'
..'EcAIQBCAACAAwAAgCFAQoACwAMAIYBDgALAA8AEAARABIAEwCHARUAEgAWAIgBGACJARoAigEcAIsBCAACAAwAAgCMAQoACwAMAI0BDgALAA8AEAARABIAEwCOARUAEgAWAI8BGACQARoAkQEcAJIBCAACAAwAAgCTAQoACwAMAJQBDgALAA8AEAARABIAEwCVARUAEgAWAJYBGACXARoAmAEcAJkBCAACAAwAAgCaAQoACwAMAJsBDgALAA8AEAARABIAEwCcARUAEgAWAJ0BGACeARoAnwEcAKABCAACAAwAAgChAQoACwAMAKIBDgALAA8AEAARABIAEwCjARUAEgAWA'
..'KQBGAClARoApgEcAKcBCAACAAwAAgCoAQoACwAMAKkBDgALAA8AEAARABIAEwCqARUAEgAWAKsBGACsARoArQEcAK4BCAACAAwAAgCvAQoACwAMALABDgALAA8AEAARABIAEwCxARUAEgAWALIBGACzARoAtAEcALUBCAACAAwAAgC2AQoACwAMALcBDgALAA8AEAARABIAEwC4ARUAEgAWAFIAGAC5ARoAVAAcALoBCAACAAwAAgC7AQoACwAMALwBDgALAA8AEAARABIAEwC9ARUAEgAWAL4BGAC/ARoAwAEcAMEBCAACAAwAAgDCAQoACwAMAMMBDgALAA8AEAARABIA'
..'EwDEARUAEgAWAMUBGADGARoAxwEcAMgBCAACAAwAAgDJAQoACwAMAMoBDgALAA8AEAARABIAEwDLARUAEgAWAMwBGADNARoAzgEcAM8BCAACAAwAAgDQAQoACwAMANEBDgALAA8AEAARABIAEwDSARUAEgAWANMBGADUARoA1QEcANYBCAACAAwAAgDXAQoACwAMANgBDgALAA8AEAARABIAEwDZARUAEgAWANoBGADbARoA3AEcAN0BCAACAAwAAgDeAQoACwAMAN8BDgALAA8AEAARABIAEwDgARUAEgAWAOEBGADiARoA4wEcAOQBCAACAAwAAgDlAQoACwAMAOYBDgA'
..'LAA8AEAARABIAEwDnARUAEgAWAOgBGADpARoA6gEcAOsBCAACAAwAAgDsAQoACwAMAHMBDgALAA8AEAARABIAEwB0ARUAEgAWAHUBGADtARoAdwEcAO4BCAACAAwAAgDvAQoACwAMAPABDgALAA8AEAARABIAEwDxARUAEgAWAPIBGADzARoA9AEcAPUBCAACAAwAAgD2AQoACwAMAPcBDgALAA8AEAARABIAEwD4ARUAEgAWAPkBGAD6ARoA+wEcAPwBCAACAAwAAgD9AQoACwAMAP4BDgALAA8AEAARABIAEwD/ARUAEgAWAAACGAABAhoAAgIcAAMCCAACAAwAAgAEAg'
..'oACwAMAAUCDgALAA8AEAARABIAEwAGAhUAEgAWAAcCGAAIAhoACQIcAAoCCAACAAwAAgALAgoACwAMAAwCDgALAA8AEAARABIAEwANAhUAEgAWAA4CGAAPAhoAEAIcABECCAACAAwAAgASAgoACwAMABMCDgALAA8AEAARABIAEwAUAhUAEgAWABUCGAAWAhoAFwIcABgCCAACAAwAAgAZAgoACwAMABoCDgALAA8AEAARABIAEwAbAhUAEgAWABwCGAAdAhoAHgIcAB8CCAACAAwAAgAgAgoACwAMACECDgALAA8AEAARABIAEwAiAhUAEgAWACMCGAAkAhoAJQIcACYCC'
..'AACAAwAAgAnAgoACwAMACgCDgALAA8AEAARABIAEwApAhUAEgAWACoCGAArAhoALAIcAC0CCAACAAwAAgAuAgoACwAMAC8CDgALAA8AEAARABIAEwAwAhUAEgAWADECGAAyAhoAMwIcADQCCAACAAwAAgA1AgoACwAMADYCDgALAA8AEAARABIAEwA3AhUAEgAWADgCGAA5AhoAOgIcADsCCAACAAwAAgA8AgoACwAMAD0CDgALAA8AEAARABIAEwA+AhUAEgAWAD8CGABAAhoAQQIcAEICCAACAAwAAgBDAgoACwAMAEQCDgALAA8AEAARABIAEwBFAhUAEgAWAEYCGABH'
..'AhoASAIcAEkCCAACAAwAAgBKAgoACwAMAEsCDgALAA8AEAARABIAEwBMAhUAEgAWAE0CGABOAhoATwIcAFACCAACAAwAAgBRAgoACwAMAFICDgALAA8AEAARABIAEwBTAhUAEgAWAFQCGABVAhoAVgIcAFcCCAACAAwAAgBYAgoACwAMAFkCDgALAA8AEAARABIAEwBaAhUAEgAWAFsCGABcAhoAXQIcAF4CCAACAAwAAgBfAgoACwAMAGACDgALAA8AEAARABIAEwBhAhUAEgAWAGICGABjAhoAZAIcAGUCCAACAAwAAgBmAgoACwAMAGcCDgALAA8AEAARABIAEwBoAhU'
..'AEgAWAGkCGABqAhoAawIcAGwCCAACAAwAAgBtAgoACwAMAG4CDgALAA8AEAARABIAEwBvAhUAEgAWAHACGABxAhoAcgIcAHMCCAACAAwAAgB0AgoACwAMAHUCDgALAA8AEAARABIAEwB2AhUAEgAWABcAGAB3AhoAGwAcAHgCCAACAAwAAgB5AgoACwAMAHoCDgALAA8AEAARABIAEwB7AhUAEgAWAHwCGAB9AhoAfgIcAH8CCAACAAwAAgCAAgoACwAMAIECDgALAA8AEAARABIAEwCCAhUAEgAWAJ0BGACDAhoAnwEcAIQCCAACAAwAAgCFAgoACwAMAIYCDgALAA8AEA'
..'ARABIAEwCHAhUAEgAWAIgCGACJAhoAigIcAIsCCAACAAwAAgCMAgoACwAMAI0CDgALAA8AEAARABIAEwCOAhUAEgAWAI8CGACQAhoAkQIcAJICCAACAA0AAgCTAgoACwAMAJQClQKWAg4ACwAPABAAEQASABMAlwIVABIAFgCYAhgAmQIaAJoCHACbAggAAgAMAAIAnAIKAAsADACdAg4ACwAPABAAEQASABMAngIVABIAFgCfAhgAoAIaAKECHACiAggAAgAMAAIAowIKAAsADACkAg4ACwAPABAAEQASABMApQIVABIAFgCmAhgApwIaAKgCHACpAggAAgAMAAIAqgIKA'
..'AsADACrAg4ACwAPABAAEQASABMArAIVABIAFgCtAhgArgIaAK8CHACwAggAAgAMAAIAsQIKAAsADACyAg4ACwAPABAAEQASABMAswIVABIAFgCrARgAtAIaAK0BHAC1AggAAgAMAAIAtgIKAAsADAC3Ag4ACwAPABAAEQASABMAuAIVABIAFgC5AhgAugIaALsCHAC8AggAAgAMAAIAvQIKAAsADAC+Ag4ACwAPABAAEQASABMAvwIVABIAFgCyARgAwAIaALQBHADBAggAAgALAAIAwgIKAAsADADDAg4ACwAPABAAEQASABMAxAIVABIAFgDFAhgAxgIaAMcCCAACAAwA'
..'AgDIAgoACwAMAMkCDgALAA8AEAARABIAEwDKAhUAEgAWAPIBGADLAhoA9AEcAMwCCAACAAwAAgDNAgoACwAMAM4CDgALAA8AEAARABIAEwDPAhUAEgAWANACGADRAhoA0gIcANMCCAACAAwAAgDUAgoACwAMANUCDgALAA8AEAARABIAEwDWAhUAEgAWANAAGADXAhoA0gAcANgCCAACAAwAAgDZAgoACwAMANoCDgALAA8AEAARABIAEwDbAhUAEgAWANwCGADdAhoA3gIcAN8CCAACAAwAAgDgAgoACwAMAOECDgALAA8AEAARABIAEwDiAhUAEgAWAOMCGADkAhoA5QI'
..'cAOYCCAACAAwAAgDnAgoACwAMAOgCDgALAA8AEAARABIAEwDpAhUAEgAWAOoCGADrAhoA7AIcAO0CCAACAAwAAgDuAgoACwAMAO8CDgALAA8AEAARABIAEwDwAhUAEgAWAPECGADyAhoA8wIcAPQCAQABAAIAAgD1AgQA9gL3AnAADAACAPgCCgALAPkC+gIMAPsClQKWAg4ACwARAPwCEwD9AhUA/gIWAP8CAAP6An4AAQMCA3EAAQADAwQDBQNAHgD3Ag8DEAMLAwD3AhEDEgP8AgD3AhMDFAMVAwD3AhYDFwP8AgD3AhEDGAP8AgD3AhkDGgMbAwD3AhEDHAP8AgD3Ah'
..'kDHQMbAwD3Ah4DHwMgAwD3AiEDIgP8AgD3Ag8DIwMLAwD3AhEDJAP8AgD3AhEDJQP8AgD3AiYDJwMoAwD3AiYDKQMoAwD3AhEDKgP8AgD3AhEDKwP8AgD3AiEDLAP8AgD3Ai0DLgP8AgD3Ah4DLwMgAwD3AhEDMAP8AgD3AhEDMQP8AgD3Ai0DMgP8AgD3AjMDNAM1AwD3AhMDNgMVAwD3AjcDOAM1AwD3AhEDOQP8AgD3AhEDOgP8AgD3AjsDPAM9AwD3AjsDPgM9A3AACQAKAAsABgMHAwwACAMJAwoDDwB7ABEACwMTAAwDFQANAxYADgM/A3MAAAABAAAAAgACAEADB'
..'ABBA0IDdQANAAoACwD5AvoCBgNDAwwARAOVApYCCQNFA0YDRwMRAEgDEwBJAxUASgMWAEsDAAP6An4AAQNMA3YAAQACAE0DTgN3AAIAAgBPA1ADCwBOA3cAAgACAFEDUAMLAFIDdwABAAIAUwNSA3cAAQACAFQDVQN3AAIAAgBWA1cDAQNYA3wADAACAE8DWQNaA1sDAQMTAFwDFgBdA14DlgJfA2ADYQNiA2MDZANlAwEDZgNnA2gDaQNqA30ABAACAGsDWwMBAxMAbAMWAG0DbgN+AAcAAgBvA1sDAQMWAHADcQNyA28DcwN0A1oDdQN2A24DfQAIAAIAdwNbAwEDeAP6'
..'AhYAeQNxA3IDbwN6A3QDWgN1A3sDbgN9AAkAAgB8A1sDAQN9A34DEwB/AxYAgANxA3IDbwOBA3QDWgN1A3YDbgN9AAkAAgCCA1sDAQN4A/oCEwCDAxYAgANxA3IDbwOEA3QDWgN1A3YDbgN9AAgAAgCFA1sDAQMTAIYDFgBtA3EDcgNvA4cDdANaA3UDdgNqA30ABAACAIgDWwMBAxMAiQMWAHkDbgOEAAoAAgCKA1sDAQN9A34DEwCLAxYAjANxA3IDbwONA3QDWgN1A3YDjgMLAGoDhAAEAAIAjwNZA5ADEwCRAxYAkgNqA4YABQACAJMDWQNaA30DWgOUAwEDFgCVA24'
..'DhAAJAAIAbwNbAwEDfQN+AxYAlgNxA3IDbwOXA3QDWgN1A3YDjgMLAGoDfQAFAAIAmAMTAJkDFgCaA14DlgKbA5wDbgOJAAgAAgBvA1sDAQMWAHADcQNyA28DnQN0A1oDdQOeA44DCwBqA30ABQACAJ8DEwCgAxYAmgNeA5YCmwOcA24DiwAHAAIAbwNbAwEDFgBwA3EDcgNvA6EDdANaA3UDngNqA30ABQACAKIDEwCjAxYApANeA5YCmwOcA24DjQAHAAIAbwNbAwEDFgBwA3EDcgNvA6UDdANaA3UDngNqA30ABAACAKYDEwCnAxYAqAObA6kDbgOPAAoAAgCqA1sDAQ'
..'MTAKsDFgCsA3EDcgNvA60DdANaA3UDdgOuA/oCrwP6Am4DkAAKAAIAsANbAwEDEwCxAxYAcANxA3IDbwOyA3QDWgN1A3YDrgP6Aq8D+gJuA48ACgACALMDWwMBAxMAtAMWAKwDcQNyA28DtQN0A1oDdQN2A64D+gKvA/oCbgOSAAoAAgCwA1sDAQMTALEDFgBwA3EDcgNvA7IDdANaA3UDdgOuA/oCrwP6Am4DjwAIAAIAdwNbAwEDFgC2A3EDcgNvA7cDdANFA3UDewOuA/oCbgOUAAgAAgC4A1kDuQN9A34DeAP6AhMAugMWALsDbwO8A3QDfgNuA48ACgACAL0DWwMBA'
..'xMAvgMWAKwDcQNyA28DawN0A1oDdQN2A64D+gKvA/oCbgOWAAoAAgCwA1sDAQMTALEDFgBwA3EDcgNvA7IDdANaA3UDdgOuA/oCrwP6Am4DjwAKAAIAvwNbAwEDEwDAAxYArANxA3IDbwPBA3QDWgN1A3YDrgP6Aq8D+gJuA5gACgACALADWwMBAxMAsQMWAHADcQNyA28DsgN0A1oDdQN2A64D+gKvA/oCbgOPAAoAAgDCA1sDAQMTAMMDFgCsA3EDcgNvA8QDdANaA3UDdgOuA/oCrwP6Am4DmgAKAAIAsANbAwEDEwCxAxYAcANxA3IDbwOyA3QDWgN1A3YDrgP6Aq8D'
..'+gJuA48ACgACAMUDWwMBAxMAxgMWAKwDcQNyA28DxwN0A1oDdQN2A64D+gKvA/oCbgOcAAoAAgCwA1sDAQMTALEDFgBwA3EDcgNvA7IDdANaA3UDdgOuA/oCrwP6Ak4DdwACAAIAyANQAwsAyQOeAAgAAgDKA8sDlgJXAwEDzAMLAM0DCwDOAwsAzwPQAxYA0QNYA58ABwACANIDWQNaA1sDAQMWAHADXwPTA2ED1ANlA6kD1QOeAAEAAgBCA9cDdwABAAIA2AM/A3cAAgACANkDUAMLANUDowABAAIA2gM/A3YAAQACANsD3AN2AAAAPwN2AAEAAgDdA94DdgAAAN8DqAA'
..'BAAIA4APfA6gAAQACAOED3wOoAAIAAgDiA9YD4wPfA6gAAgACAOQD1gMEA+UDqAABAAIA5gNSA6gAAQACAOcD6AN2AAYAAgDpA+oDCwDrA+wD7QNyA+4D7wPwAwEDPwOvAAEAAgDpAz8DdgABAAIA8QPoA3YABwACAPID6gMLAPMD9APrA+wD7QNyA+4D9QPwA+wDPwOyAAEAAgDpAz8DdgABAAIA9gMIAHUADQACAPIDCgALAAYD9wMMAPgDCQP5Aw8AewARAPoDEwD7AxUA/AMWAP0DfgABAxgA/gMaAP8D9wJ1AA8AAgBrAwoACwAABOwD+QLsAwwAAQQCBOwDAwTsAw'
..'4ACwARABIAEwAEBAUE7AMVABIAFgAGBAAD7AN+AAEDBwS2AAIAAgAIBAkECgQLBLYABAACAAwEDQQKBA4EAQMPBAoEPwO2AAAA6AO2AAkAAgAQBOoDCwDzA/oCEQQLAOsDEgQTBBQE7QMBA+4DFQTwA/oC3wO2AAEAAgCIA98DtgABAAIAFgTfA7YAAQACABcE9wJ1AAoAAgAYBAoACwD5AvoCDAAZBBEAEgATABoEFQASABYAGwQAA/oCfgABAxwEvgAMAB0EHgQfBCAEywOWAiEEIgTPAwEDIwQkBBUAJQQWACYEfAMnBCgEKQQqBCsEfgAsBOgDvgAEAOoDCwDtAwED7'
..'gMtBPAD7AM/A74AAAA/A8EAAgACAC4EUAMLAPcCdQAKAAIALwQKAAsA+QL6AgwAMAQRADEEEwAyBBUAMwQWADQEAAP6An4AAQM1BMMABgBXAwEDzgMLADYEcgM3BDgEOQQBAzoEAQNqA8QAAwBZAzsEeAP6AhYAPARqA8QABABZAzsEeAP6AhMAPQQWAD4EagPEAAUAWQM7BFsDAQN4A/oCEwA/BBYAQAQ/A8cAAABqA8cABABZAzsEeAP6AhMAQQQWAEIEagPJAAQAWQM7BHgD+gITAEMEFgBEBGoDyQAEAFkDOwR4A/oCEwBFBBYARARqA8kABABZAzsEeAP6AhMARgQW'
..'AEQEagPJAAQAWQM7BHgD+gITAEcEFgBwA2oDyQAEAFkDOwR4A/oCEwBIBBYARARqA8kABABZAzsEeAP6AhMASQQWAEQEagPJAAQAWQM7BHgD+gITAEoEFgBEBGoDyQAFAAIASwRZAzsEeAP6AhMATAQWAEQEagPJAAUAAgBLBFkDOwR4A/oCEwBNBBYARARqA8kABABZAzsEeAP6AhMATgQWAEQEagPJAAQAWQM7BHgD+gITAE8EFgBEBGoDyQAEAFkDOwR4A/oCEwBQBBYARARqA8kABABZAzsEeAP6AhMAUQQWAEQEagPJAAQAWQM7BHgD+gITAFIEFgBEBGoDyQAEAFk'
..'DOwR4A/oCEwBTBBYARARqA8kABABZAzsEeAP6AhMAVAQWAEQEagPJAAQAWQM7BHgD+gITAFUEFgBEBGoDyQAFAAIASwRZAzsEeAP6AhMAVgQWAEQEagPJAAUAAgBLBFkDOwR4A/oCEwBXBBYARARqA8kABQACAEsEWQM7BHgD+gITAFgEFgBEBGoDyQAFAAIASwRZAzsEeAP6AhMAWQQWAEQEagPJAAUAAgBLBFkDOwR4A/oCEwBaBBYARARqA8kABQACAEsEWQM7BHgD+gITAFsEFgBEBGoDyQAFAAIASwRZAzsEeAP6AhMAXAQWAEQEagPJAAUAAgBLBFkDOwR4A/oCEw'
..'BdBBYARARuA8QACQBZA1oDWwMBA3gD7AMTAF4EFgBfBHED7ANvA2AEdAM7BHUDYQQ/A+MAAABqA8QABABZAzsEeAP6AhMAYgQWAGMEagPEAAQAWQM7BHgD+gITAGQEFgBlBGoD5gAEAFkDOwR4A/oCEwBmBBYAZwRqA8QABABZAzsEeAP6AhMAaAQWADwEbgPEAAoAWQNaA1sDAQN4A+wDEwBpBBYAXwRxA+wDbwNgBHQDOwR1A2EErwP6Aj8D6QAAAG4DxAAJAFkDWgNbAwEDeAPsAxMAagQWAF8EcQPsA28DjQN0AzsEdQNhBD8D6wAAADUEwwAGAFcDAQPOAwsANgRyA'
..'zcEOAQ5BAEDOgQBA24D7QAJAFkDWgNbAwEDeAPsAxMAXgQWAF8EcQPsA28DYAR0AzsEdQNhBD8D7gAAAG4D7QAKAFkDWgNbAwEDeAPsAxMAaQQWAF8EcQPsA28DYAR0AzsEdQNhBK8D+gI/A/AAAABuA+0ACQBZA1oDWwMBA3gD7AMTAGoEFgBfBHED7ANvA40DdAM7BHUDYQQ/A/IAAABuA+0ACgBZA1oDWwMBA3gD7AMTAGkEFgBfBHED7ANvA2AEdAM7BHUDYQSvA/oCPwP0AAAAbgPtAAkAWQNaA1sDAQN4A+wDEwBqBBYAXwRxA+wDbwONA3QDOwR1A2EEPwP2AAAA'
..'bgPtAAkAWQNaA1sDAQN4A+wDEwBeBBYAXwRxA+wDbwNgBHQDOwR1A2EEPwP4AAAAbgPtAAoAWQNaA1sDAQN4A+wDEwBpBBYAXwRxA+wDbwNgBHQDOwR1A2EErwP6Aj8D+gAAAG4D7QAJAFkDWgNbAwEDeAPsAxMAagQWAF8EcQPsA28DjQN0AzsEdQNhBD8D/AAAAG4D7QAJAFkDWgNbAwEDeAPsAxMAXgQWAF8EcQPsA28DYAR0AzsEdQNhBD8D/gAAAG4D7QAKAFkDWgNbAwEDeAPsAxMAaQQWAF8EcQPsA28DYAR0AzsEdQNhBK8D+gI/AwABAABuA+0ACQBZA1oDWwM'
..'BA3gD7AMTAGoEFgBfBHED7ANvA40DdAM7BHUDYQQ/AwIBAABuA+0ACQBZA1oDWwMBA3gD7AMTAF4EFgBfBHED7ANvA2AEdAM7BHUDYQQ/AwQBAABuA+0ACgBZA1oDWwMBA3gD7AMTAGkEFgBfBHED7ANvA2AEdAM7BHUDYQSvA/oCPwMGAQAAbgPtAAkAWQNaA1sDAQN4A+wDEwBqBBYAXwRxA+wDbwONA3QDOwR1A2EEPwMIAQAAbgPtAAkAWQNaA1sDAQN4A+wDEwBeBBYAXwRxA+wDbwNgBHQDOwR1A2EEPwMKAQAAbgPtAAoAWQNaA1sDAQN4A+wDEwBpBBYAXwRxA+'
..'wDbwNgBHQDOwR1A2EErwP6Aj8DDAEAAG4D7QAJAFkDWgNbAwEDeAPsAxMAagQWAF8EcQPsA28DjQN0AzsEdQNhBD8DDgEAAG4D7QAJAFkDWgNbAwEDeAPsAxMAXgQWAF8EcQPsA28DYAR0AzsEdQNhBD8DEAEAAG4D7QAKAFkDWgNbAwEDeAPsAxMAaQQWAF8EcQPsA28DYAR0AzsEdQNhBK8D+gI/AxIBAABuA+0ACQBZA1oDWwMBA3gD7AMTAGoEFgBfBHED7ANvA40DdAM7BHUDYQQ/AxQBAABuA+0ACQBZA1oDWwMBA3gD7AMTAF4EFgBfBHED7ANvA2AEdAM7BHUDY'
..'QQ/AxYBAABuA+0ACgBZA1oDWwMBA3gD7AMTAGkEFgBfBHED7ANvA2AEdAM7BHUDYQSvA/oCPwMYAQAAbgPtAAkAWQNaA1sDAQN4A+wDEwBqBBYAXwRxA+wDbwONA3QDOwR1A2EEPwMaAQAAbgPtAAkAWQNaA1sDAQN4A+wDEwBeBBYAXwRxA+wDbwNgBHQDOwR1A2EEPwMcAQAAbgPtAAoAWQNaA1sDAQN4A+wDEwBpBBYAXwRxA+wDbwNgBHQDOwR1A2EErwP6Aj8DHgEAAG4D7QAJAFkDWgNbAwEDeAPsAxMAagQWAF8EcQPsA28DjQN0AzsEdQNhBD8DIAEAAG4D7QAJ'
..'AFkDWgNbAwEDeAPsAxMAXgQWAF8EcQPsA28DYAR0AzsEdQNhBD8DIgEAAG4D7QAKAFkDWgNbAwEDeAPsAxMAaQQWAF8EcQPsA28DYAR0AzsEdQNhBK8D+gI/AyQBAABuA+0ACQBZA1oDWwMBA3gD7AMTAGoEFgBfBHED7ANvA40DdAM7BHUDYQQ/AyYBAABuA+0ACQBZA1oDWwMBA3gD7AMTAF4EFgBfBHED7ANvA2AEdAM7BHUDYQQ/AygBAABuA+0ACgBZA1oDWwMBA3gD7AMTAGkEFgBfBHED7ANvA2AEdAM7BHUDYQSvA/oCPwMqAQAAbgPtAAkAWQNaA1sDAQN4A+w'
..'DEwBqBBYAXwRxA+wDbwONA3QDOwR1A2EEPwMsAQAAbgPtAAkAWQNaA1sDAQN4A+wDEwBeBBYAXwRxA+wDbwNgBHQDOwR1A2EEPwMuAQAAbgPtAAoAWQNaA1sDAQN4A+wDEwBpBBYAXwRxA+wDbwNgBHQDOwR1A2EErwP6Aj8DMAEAAG4D7QAJAFkDWgNbAwEDeAPsAxMAagQWAF8EcQPsA28DjQN0AzsEdQNhBD8DMgEAAG4D7QAJAFkDWgNbAwEDeAPsAxMAXgQWAF8EcQPsA28DYAR0AzsEdQNhBD8DNAEAAG4D7QAKAFkDWgNbAwEDeAPsAxMAaQQWAF8EcQPsA28DYA'
..'R0AzsEdQNhBK8D+gI/AzYBAABuA+0ACQBZA1oDWwMBA3gD7AMTAGoEFgBfBHED7ANvA40DdAM7BHUDYQQ/AzgBAABuA+0ACQBZA1oDWwMBA3gD7AMTAF4EFgBfBHED7ANvA2AEdAM7BHUDYQQ/AzoBAABuA+0ACgBZA1oDWwMBA3gD7AMTAGkEFgBfBHED7ANvA2AEdAM7BHUDYQSvA/oCPwM8AQAAbgPtAAkAWQNaA1sDAQN4A+wDEwBqBBYAXwRxA+wDbwONA3QDOwR1A2EEPwM+AQAAbgPtAAkAWQNaA1sDAQN4A+wDEwBeBBYAXwRxA+wDbwNgBHQDOwR1A2EEPwNAA'
..'QAAbgPtAAoAWQNaA1sDAQN4A+wDEwBpBBYAXwRxA+wDbwNgBHQDOwR1A2EErwP6Aj8DQgEAAG4D7QAJAFkDWgNbAwEDeAPsAxMAagQWAF8EcQPsA28DjQN0AzsEdQNhBD8DRAEAAG4D7QAJAFkDWgNbAwEDeAPsAxMAXgQWAF8EcQPsA28DYAR0AzsEdQNhBD8DRgEAAG4D7QAKAFkDWgNbAwEDeAPsAxMAaQQWAF8EcQPsA28DYAR0AzsEdQNhBK8D+gI/A0gBAABuA+0ACQBZA1oDWwMBA3gD7AMTAGoEFgBfBHED7ANvA40DdAM7BHUDYQQ/A0oBAABuA+0ACQBZA1oD'
..'WwMBA3gD7AMTAF4EFgBfBHED7ANvA2AEdAM7BHUDYQQ/A0wBAABuA+0ACgBZA1oDWwMBA3gD7AMTAGkEFgBfBHED7ANvA2AEdAM7BHUDYQSvA/oCPwNOAQAAbgPtAAkAWQNaA1sDAQN4A+wDEwBqBBYAXwRxA+wDbwONA3QDOwR1A2EEPwNQAQAAbgPtAAkAWQNaA1sDAQN4A+wDEwBeBBYAXwRxA+wDbwNgBHQDOwR1A2EEPwNSAQAAbgPtAAoAWQNaA1sDAQN4A+wDEwBpBBYAXwRxA+wDbwNgBHQDOwR1A2EErwP6Aj8DVAEAAG4D7QAJAFkDWgNbAwEDeAPsAxMAagQ'
..'WAF8EcQPsA28DjQN0AzsEdQNhBD8DVgEAAG4D7QAJAFkDWgNbAwEDeAPsAxMAXgQWAF8EcQPsA28DYAR0AzsEdQNhBD8DWAEAAPcCdQAKAAIA6AMKAAsA+QL6AgwAawQRAGwEEwBtBBUAbgQWAG8EAAP6An4AAQPoA1oBBgDqAwsA8wP6AhEECwDtAwED7gNwBPADIARxBFsBBAACAHIEcwR0BHUE+gJ2BOwDPwNaAQAA1QNdAQEAAgB3BPcCdQAMAAIAeAQKAAsA+QL6AgwAeQSVApYCRgN6BBEAewQTAHwEFQB9BBYAfgQAA/oCfgABAz8DXwEAAOgDXwEGAPMDfwTrA4'
..'AEEwSpA+0DAQPuA4EE8AMBA/cCdQALAAIAggQKAAsA+QL6AgwAgwSVApYCEQCEBBMAhQQVAIYEFgCHBAAD+gJ+AAEDAQB1AAIAAgCIBAQAiQT3AmMBCQACAE8D+QL6AgwAigQRAIQEEwCLBBUAhgQWAIcEAAP6An4AAQOMBGQBBAACAI0EjgSPBL0DkASTBJQEPwNlAQAACABjAQ0AAgCVBAoACwAMAJYElQKWAg4ACwAPABAAEQASABMAlwQVABIAFgCYBBgAmQQaAJoEHACbBAgAYwENAAIAnAQKAAsADACdBJUClgIOAAsADwAQABEAEgATAJ4EFQASABYAmAQYAJ8EG'
..'gCaBBwAoAQ/A2MBAQACAKEEAQB1AAIAAgCiBAQAowT3AmoBCQACAKQE+QL6AgwApQQRAKYEEwCnBBUApgQWAKgEAAP6An4AAQOMBGsBBAACAKQEjgSpBL0DqgSTBJQEPwNsAQAA9wJqAQkAAgCrBPkC+gIMAKwEEQCtBBMArgQVAK0EFgCoBAAD+gJ+AAEDjARuAQQAAgCrBI4ErwS9A7AEkwSUBD8DbwEAAAEAagECAAIAsQQEALIECABxAQ0AAgCzBAoACwAMALQElQKWAg4ACwAPABAAEQC1BBMAtgQVALcEFgC4BBgAuQQaALoEHAC7BAgAcQENAAIAvAQKAAsADAC9'
..'BJUClgIOAAsADwAQABEAtQQTAL4EFQC3BBYAvwQYAMAEGgDBBBwAwgQIAHEBDQACAMMECgALAAwAxASVApYCDgALAA8AEAARAMUEEwDGBBUAxQQWAMcEGADIBBoAyQQcAMoEjAR0AQIAAgCkBI4EywQ/A3EBAQACAKEEAQBqAQIAAgDMBAQAzQQIAHcBCgACAM4EDADPBA8AEAARANAEEwDRBBUA0gQWANMEGADUBBoA1QQcANYECAB3AQoAAgDXBAwA2AQPABAAEQDQBBMA2QQVANIEFgDaBBgA2wQaANwEHADdBAgAdwEKAAIA3gQMAN8EDwAQABEAEgATAOAEFQASABY'
..'A4QQYAOIEGgDjBBwA5AQIAHcBCgACAOUEDADmBA8AEAARABIAEwDnBBUAEgAWAOgEGADpBBoA6gQcAOsECAB3AQoAAgDsBAwA7QQPABAAEQDQBBMA7gQVANIEFgDvBBgA8AQaAPEEHADyBIwEfAECAAIAqwSOBPMEPwN3AQEAAgChBPcCdQAKAAIA9AQKAAsA+QL6AgwA9QQRAKYEEwD2BBUApgQWAKgEAAP6An4AAQP3AnUACgACAPcECgALAPkC+gIMAPgEEQCtBBMA+QQVAK0EFgCoBAAD+gJ+AAEDAQB1AAIAAgD6BAQA+wQ/A4EBAQACAPwE9wKBAQoAAgD9BAoACw'
..'D5AvoCDAD+BBEA/wQTAAAFFQABBRYAAgUAA/oCfgABA4wEgwEDAAIAjQQDBQQFkwQFBQEAgQECAAIABgUEAAcF9wKFAQoAAgAIBfkC+gIMAP4ElQKWAhEA/wQTAAAFFQABBRYAAgUAA/oCfgABAz8DhQEBAAIAoQQIAIUBDAACAAkFCgALAAwACgUOAAsADwB7ABEAEgATAAsFFQASABYADAV+AH8AGAANBRoADgUIAIUBDQACAA8FCgALAAwAEAWVApYCDgALAA8AEAARABIAEwARBRUAEgAWABIFGAATBRoAFAUcABUFCACFAQ0AAgAWBQoACwAMABcFlQKWAg4ACwAPA'
..'BAAEQASABMAGAUVABIAFgAZBRgAGgUaABsFHAAcBQEAdQACAAIAhQMEAB0FAQCLAQIAAgAeBQQAHwUIAIwBDQACACAFCgALAAwAIQWVApYCRgMiBQ8AEAARABIAEwAjBRUAEgAWACQFGAAlBRoAJgUcACcFCACMAQwAAgAoBQoACwAMACkFRgMiBQ8AEAARABIAEwAqBRUAEgAWACsFGAAsBRoALQUcAC4FCACMAQ0AAgAvBQoACwAMADAFlQKWAkYDIgUPABAAEQASABMAMQUVABIAFgAyBRgAMwUaADQFHAA1BQgAjAENAAIANgUKAAsADAA3BZUClgJGAyIFDwAQABEA'
..'EgATADgFFQASABYAOQUYADoFGgA7BRwAPAU/A4wBAQACAKEE9wKMAQcAAgA9BfkC+gIMAD4FEwA/BRYAbwQAA/oCfgABAwEAiwECAAIAHgUEAEAFCACTAQwAAgBBBQoACwAMAEIFRgMiBQ8AEAARABIAEwBDBRUAEgAWAEQFGABFBRoARgUcAEcFCACTAQ0AAgBIBQoACwAMAEkFlQKWAkYDIgUPABAAEQASABMASgUVABIAFgBLBRgATAUaAE0FHABOBQgAkwENAAIATwUKAAsADABQBZUClgJGAyIFDwAQABEAEgATAFEFFQASABYAUgUYAFMFGgBUBRwAVQUIAJMBDQA'
..'CAFYFCgALAAwAVwWVApYCRgMiBQ8AEAARABIAEwBYBRUAEgAWAFkFGABaBRoAWwUcAFwFPwOTAQEAAgChBPcCkwEHAAIAPQX5AvoCDABdBRMAXgUWAG8EAAP6An4AAQMBAIsBAgACAB4FBABfBQgAmgENAAIAYAUKAAsADABhBZUClgJGAyIFDwAQABEAEgATAGIFFQASABYAYwUYAGQFGgBlBRwAZgUIAJoBDQACAGcFCgALAAwAaAWVApYCRgMiBQ8AEAARABIAEwBpBRUAEgAWAGoFGABrBRoAbAUcAG0FCACaAQ0AAgBuBQoACwAMAG8FlQKWAkYDIgUPABAAEQASAB'
..'MAcAUVABIAFgBxBRgAcgUaAHMFHAB0BQgAmgENAAIAdQUKAAsADAB2BZUClgJGAyIFDwAQABEAEgATAHcFFQASABYAeAUYAHkFGgB6BRwAewUIAJoBDQACAHwFCgALAAwAfQWVApYCRgMiBQ8AEAARABIAEwB+BRUAEgAWAH8FGACABRoAgQUcAIIFCACaAQ0AAgCDBQoACwAMAIQFlQKWAkYDIgUPABAAEQASABMAhQUVABIAFgCGBRgAhwUaAIgFHACJBQgAmgENAAIAigUKAAsADACLBZUClgJGAyIFDwAQABEAEgATAIwFFQASABYAjQUYAI4FGgCPBRwAkAUIAJoBD'
..'gACAJEFCgALAAYD9wMMAJIFlQKWAgkD+QNGA5MFDwCUBREAEgATAJUFFQASABYAlgUYAJcFGgCYBQgAmgENAAIAmQUKAAsADACaBZUClgJGAyIFDwAQABEAEgATAJsFFQASABYAnAUYAJ0FGgCeBRwAnwUIAJoBDAACAKAFCgALAAwAoQVGAyIFDwAQABEAEgATAKIFFQASABYAowUYAKQFGgClBRwApgUIAJoBDQACAKcFCgALAAwAqAWVApYCRgMiBQ8AEAARABIAEwCpBRUAEgAWAKoFGACrBRoArAUcAK0F9wKaAQcAAgA9BfkC+gIMAK4FEwCvBRYAbwQAA/oCfgAB'
..'Az8DmgEBAAIAoQQBAIsBAgACALAFBACxBQgAqAEMAAIAsgUKAAsADACzBZUClgIPABAAEQASABMAtAUVABIAFgC1BRgAtgUaALcFHAC4BQgAqAEMAAIAuQUKAAsADAC6BZUClgIPABAAEQASABMAuwUVABIAFgC8BRgAvQUaAL4FHAC/BT8DqAEBAAIAoQT3AqgBCgACAD0F+QL6AgwAwAWVApYCEQDBBRMAwgUVAMEFFgBvBAAD+gJ+AAEDPwOLAQAA9wJ1AAsAAgDDBQoACwD5AvoCDADABZUClgIRAMEFEwDCBRUAwQUWAG8EAAP6An4AAQOMBK4BAQCTBJQE3wOvAQI'
..'AAgDEBdYDxQX3AnUACAACAMYFCgALAPkC+gIMAK4FEwCvBRYAbwQAA/oCfgABA4wEsQEBAJMElATfA7IBAgACAMQF1gPHBfcCdQAIAAIAxgUKAAsA+QL6AgwAXQUTAF4FFgBvBAAD+gJ+AAEDjAS0AQEAkwSUBN8DtQECAAIAxAXWA8cF9wJ1AAgAAgDGBQoACwD5AvoCDAA+BRMAPwUWAG8EAAP6An4AAQOMBLcBAQCTBJQE3wO4AQIAAgDEBdYDxwUWoQDWA3YApADWA7UAZQGRBGQBZQGSBGIBbAGRBGsBbAGSBH8BbwGRBG4BbwGSBIABdQGRBHQBdQGSBGsBfQGRBH'
..'wBfQGSBG4BhAGRBIMBhAGSBIYBrwGRBK4BrwGSBKwBsgGRBLEBsgGSBKYBtQGRBLQBtQGSBJkBuAGRBLcBuAGSBJIB')
for _,obj in pairs(Objects) do
	obj.Parent = script or workspace
end

RunScripts()
